{"ast":null,"code":"var ClientRequest = require('./request');\n\nvar IncomingMessage = require('./incoming-message');\n\nvar statusCodes = require('builtin-status-codes');\n\nvar URL = self.URL;\n\nconst request = (opts, cb) => {\n  if (typeof opts === 'string') {\n    opts = new URL(opts, self.location.protocol + '//' + self.location.host);\n    opts.path = opts.pathname + opts.search;\n    opts.auth = opts.username && opts.password ? opts.username + ':' + opts.password : null;\n  } else {\n    opts = Object.assign({}, opts);\n  } // Normally, the page is loaded from http or https, so not specifying a protocol\n  // will result in a (valid) protocol-relative url. However, this won't work if\n  // the protocol is something else, like 'file:'\n\n\n  var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : '';\n  var protocol = opts.protocol || defaultProtocol;\n  var host = opts.hostname || opts.host;\n  var port = opts.port;\n  var path = opts.path || '/'; // Necessary for IPv6 addresses\n\n  if (host && host.indexOf(':') !== -1) host = '[' + host + ']'; // This may be a relative url. The browser should always be able to interpret it correctly.\n\n  opts.url = (host ? protocol + '//' + host : '') + (port ? ':' + port : '') + path;\n  opts.method = (opts.method || 'GET').toUpperCase();\n  opts.headers = opts.headers || {}; // Also valid opts.auth, opts.mode\n\n  var req = new ClientRequest(opts);\n  if (cb) req.on('response', cb);\n  return req;\n};\n\nconst get = (opts, cb) => {\n  var req = request(opts, cb);\n  req.end();\n  return req;\n};\n\nconst Agent = function () {};\n\nAgent.defaultMaxSockets = 4;\nconst METHODS = ['CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REPORT', 'SEARCH', 'SUBSCRIBE', 'TRACE', 'UNLOCK', 'UNSUBSCRIBE'];\nmodule.exports = {\n  Agent,\n  ClientRequest,\n  IncomingMessage,\n  METHODS,\n  STATUS_CODES: statusCodes,\n  get,\n  globalAgent: new Agent(),\n  request,\n  maxHeaderSize: '8KB'\n};","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/iso-stream-http/lib/http.js"],"names":["ClientRequest","require","IncomingMessage","statusCodes","URL","self","request","opts","cb","location","protocol","host","path","pathname","search","auth","username","password","Object","assign","defaultProtocol","global","hostname","port","indexOf","url","method","toUpperCase","headers","req","on","get","end","Agent","defaultMaxSockets","METHODS","module","exports","STATUS_CODES","globalAgent","maxHeaderSize"],"mappings":"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","sourcesContent":["var ClientRequest = require('./request')\r\nvar IncomingMessage = require('./incoming-message')\r\nvar statusCodes = require('builtin-status-codes')\r\nvar URL = self.URL\r\n\r\n\r\nconst request = (opts, cb) => {\r\n\tif (typeof opts === 'string') {\r\n\r\n\t\topts = new URL(opts, self.location.protocol + '//' +self.location.host)\r\n\t\topts.path = opts.pathname + opts.search\r\n\t\topts.auth = (opts.username && opts.password) ? opts.username + ':' + opts.password : null\r\n\t} else {\r\n\t\topts = Object.assign({}, opts)\r\n\t}\r\n\r\n\t// Normally, the page is loaded from http or https, so not specifying a protocol\r\n\t// will result in a (valid) protocol-relative url. However, this won't work if\r\n\t// the protocol is something else, like 'file:'\r\n\tvar defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''\r\n\r\n\tvar protocol = opts.protocol || defaultProtocol\r\n\tvar host = opts.hostname || opts.host\r\n\tvar port = opts.port\r\n\tvar path = opts.path || '/'\r\n\r\n\t// Necessary for IPv6 addresses\r\n\tif (host && host.indexOf(':') !== -1)\r\n\t\thost = '[' + host + ']'\r\n\r\n\t// This may be a relative url. The browser should always be able to interpret it correctly.\r\n\topts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path\r\n\topts.method = (opts.method || 'GET').toUpperCase()\r\n\topts.headers = opts.headers || {}\r\n\r\n\t// Also valid opts.auth, opts.mode\r\n\r\n\tvar req = new ClientRequest(opts)\r\n\tif (cb)\r\n\t\treq.on('response', cb)\r\n\treturn req\r\n}\r\n\r\nconst get = (opts, cb) => {\r\n\tvar req = request(opts, cb)\r\n\treq.end()\r\n\treturn req\r\n}\r\n\r\nconst Agent = function () {}\r\nAgent.defaultMaxSockets = 4\r\n\r\nconst METHODS = [\r\n\t'CHECKOUT',\r\n\t'CONNECT',\r\n\t'COPY',\r\n\t'DELETE',\r\n\t'GET',\r\n\t'HEAD',\r\n\t'LOCK',\r\n\t'M-SEARCH',\r\n\t'MERGE',\r\n\t'MKACTIVITY',\r\n\t'MKCOL',\r\n\t'MOVE',\r\n\t'NOTIFY',\r\n\t'OPTIONS',\r\n\t'PATCH',\r\n\t'POST',\r\n\t'PROPFIND',\r\n\t'PROPPATCH',\r\n\t'PURGE',\r\n\t'PUT',\r\n\t'REPORT',\r\n\t'SEARCH',\r\n\t'SUBSCRIBE',\r\n\t'TRACE',\r\n\t'UNLOCK',\r\n\t'UNSUBSCRIBE'\r\n]\r\n\r\nmodule.exports = {\r\n\tAgent,\r\n\tClientRequest,\r\n\tIncomingMessage,\r\n\tMETHODS,\r\n\tSTATUS_CODES: statusCodes,\r\n\tget,\r\n\tglobalAgent : new Agent(),\r\n\trequest,\r\n\tmaxHeaderSize: '8KB'\r\n\r\n}"]},"metadata":{},"sourceType":"script"}