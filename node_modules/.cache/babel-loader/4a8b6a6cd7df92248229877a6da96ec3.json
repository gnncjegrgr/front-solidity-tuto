{"ast":null,"code":"'use strict';\n\nconst assert = require('assert');\n\nconst withIs = require('class-is');\n\nconst addNamedLink = require('./addNamedLink');\n\nconst visibility = require('../visibility');\n\nclass DAGNode {\n  constructor(data, links, serializedSize) {\n    if (serializedSize !== 0) {\n      assert(serializedSize, 'A DAGNode requires it\\'s serialized size');\n    }\n\n    this._data = data || Buffer.alloc(0);\n    this._links = links;\n    this._serializedSize = serializedSize; // Make sure we have a nice public API that can be used by an IPLD resolver\n\n    visibility.hidePrivateFields(this);\n    visibility.addEnumerableGetters(this, ['Data', 'Links']); // Add getters for existing links by the name of the link\n    // This is how paths are traversed in IPFS. Links with names won't\n    // override existing fields like `data` or `links`.\n\n    links.forEach((link, position) => {\n      addNamedLink(this, link.Name, position);\n    });\n  }\n\n  toJSON() {\n    if (!this._json) {\n      this._json = Object.freeze({\n        data: this.Data,\n        links: this._links.map(l => l.toJSON()),\n        size: this.size\n      });\n    }\n\n    return Object.assign({}, this._json);\n  }\n\n  toString() {\n    return `DAGNode <data: \"${this.Data.toString('base64')}\", links: ${this.Links.length}, size: ${this.size}>`;\n  }\n\n  get size() {\n    if (this._size === undefined) {\n      this._size = this._links.reduce((sum, l) => sum + l.Tsize, this._serializedSize);\n    }\n\n    return this._size;\n  }\n\n  set size(size) {\n    throw new Error(\"Can't set property: 'size' is immutable\");\n  } // Getters for backwards compatible path resolving\n\n\n  get Data() {\n    return this._data;\n  }\n\n  set Data(_) {\n    throw new Error(\"Can't set property: 'Data' is immutable\");\n  }\n\n  get Links() {\n    return this._links.map(link => {\n      return {\n        Name: link.Name,\n        Tsize: link.Tsize,\n        Hash: link.Hash\n      };\n    });\n  }\n\n  set Links(_) {\n    throw new Error(\"Can't set property: 'Links' is immutable\");\n  }\n\n}\n\nexports = module.exports = withIs(DAGNode, {\n  className: 'DAGNode',\n  symbolName: '@ipld/js-ipld-dag-pb/dagnode'\n});\nexports.create = require('./create');\nexports.clone = require('./clone');\nexports.addLink = require('./addLink');\nexports.rmLink = require('./rmLink');","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/ipld-dag-pb/src/dag-node/index.js"],"names":["assert","require","withIs","addNamedLink","visibility","DAGNode","constructor","data","links","serializedSize","_data","Buffer","alloc","_links","_serializedSize","hidePrivateFields","addEnumerableGetters","forEach","link","position","Name","toJSON","_json","Object","freeze","Data","map","l","size","assign","toString","Links","length","_size","undefined","reduce","sum","Tsize","Error","_","Hash","exports","module","className","symbolName","create","clone","addLink","rmLink"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst assert = require('assert')\r\nconst withIs = require('class-is')\r\nconst addNamedLink = require('./addNamedLink')\r\nconst visibility = require('../visibility')\r\n\r\nclass DAGNode {\r\n  constructor (data, links, serializedSize) {\r\n    if (serializedSize !== 0) {\r\n      assert(serializedSize, 'A DAGNode requires it\\'s serialized size')\r\n    }\r\n\r\n    this._data = data || Buffer.alloc(0)\r\n    this._links = links\r\n    this._serializedSize = serializedSize\r\n\r\n    // Make sure we have a nice public API that can be used by an IPLD resolver\r\n    visibility.hidePrivateFields(this)\r\n    visibility.addEnumerableGetters(this, ['Data', 'Links'])\r\n\r\n    // Add getters for existing links by the name of the link\r\n    // This is how paths are traversed in IPFS. Links with names won't\r\n    // override existing fields like `data` or `links`.\r\n    links.forEach((link, position) => {\r\n      addNamedLink(this, link.Name, position)\r\n    })\r\n  }\r\n\r\n  toJSON () {\r\n    if (!this._json) {\r\n      this._json = Object.freeze({\r\n        data: this.Data,\r\n        links: this._links.map((l) => l.toJSON()),\r\n        size: this.size\r\n      })\r\n    }\r\n\r\n    return Object.assign({}, this._json)\r\n  }\r\n\r\n  toString () {\r\n    return `DAGNode <data: \"${this.Data.toString('base64')}\", links: ${this.Links.length}, size: ${this.size}>`\r\n  }\r\n\r\n  get size () {\r\n    if (this._size === undefined) {\r\n      this._size = this._links.reduce((sum, l) => sum + l.Tsize, this._serializedSize)\r\n    }\r\n\r\n    return this._size\r\n  }\r\n\r\n  set size (size) {\r\n    throw new Error(\"Can't set property: 'size' is immutable\")\r\n  }\r\n\r\n  // Getters for backwards compatible path resolving\r\n  get Data () {\r\n    return this._data\r\n  }\r\n  set Data (_) {\r\n    throw new Error(\"Can't set property: 'Data' is immutable\")\r\n  }\r\n  get Links () {\r\n    return this._links.map((link) => {\r\n      return {\r\n        Name: link.Name,\r\n        Tsize: link.Tsize,\r\n        Hash: link.Hash\r\n      }\r\n    })\r\n  }\r\n  set Links (_) {\r\n    throw new Error(\"Can't set property: 'Links' is immutable\")\r\n  }\r\n}\r\n\r\nexports = module.exports = withIs(DAGNode, { className: 'DAGNode', symbolName: '@ipld/js-ipld-dag-pb/dagnode' })\r\nexports.create = require('./create')\r\nexports.clone = require('./clone')\r\nexports.addLink = require('./addLink')\r\nexports.rmLink = require('./rmLink')\r\n"]},"metadata":{},"sourceType":"script"}