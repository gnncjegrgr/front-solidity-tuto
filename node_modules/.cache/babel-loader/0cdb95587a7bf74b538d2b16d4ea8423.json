{"ast":null,"code":"'use strict';\n\nconst protobuf = require('protons');\n\nconst keysPBM = protobuf(require('./keys.proto'));\n\nrequire('node-forge/lib/asn1');\n\nrequire('node-forge/lib/rsa');\n\nrequire('node-forge/lib/pbe');\n\nconst forge = require('node-forge/lib/forge');\n\nexports = module.exports;\nconst supportedKeys = {\n  rsa: require('./rsa-class'),\n  ed25519: require('./ed25519-class'),\n  secp256k1: require('libp2p-crypto-secp256k1')(keysPBM, require('../random-bytes'))\n};\nexports.supportedKeys = supportedKeys;\nexports.keysPBM = keysPBM;\n\nfunction isValidKeyType(keyType) {\n  const key = supportedKeys[keyType.toLowerCase()];\n  return key !== undefined;\n}\n\nexports.keyStretcher = require('./key-stretcher');\nexports.generateEphemeralKeyPair = require('./ephemeral-keys'); // Generates a keypair of the given type and bitsize\n\nexports.generateKeyPair = (type, bits, cb) => {\n  const key = supportedKeys[type.toLowerCase()];\n\n  if (!key) {\n    return cb(new Error('invalid or unsupported key type'));\n  }\n\n  key.generateKeyPair(bits, cb);\n}; // Generates a keypair of the given type and bitsize\n// seed is a 32 byte uint8array\n\n\nexports.generateKeyPairFromSeed = (type, seed, bits, cb) => {\n  const key = supportedKeys[type.toLowerCase()];\n\n  if (!key) {\n    return cb(new Error('invalid or unsupported key type'));\n  }\n\n  if (type.toLowerCase() !== 'ed25519') {\n    return cb(new Error('Seed key derivation is unimplemented for RSA or secp256k1'));\n  }\n\n  key.generateKeyPairFromSeed(seed, bits, cb);\n}; // Converts a protobuf serialized public key into its\n// representative object\n\n\nexports.unmarshalPublicKey = buf => {\n  const decoded = keysPBM.PublicKey.decode(buf);\n  const data = decoded.Data;\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data);\n\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);\n\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);\n      } else {\n        throw new Error('secp256k1 support requires libp2p-crypto-secp256k1 package');\n      }\n\n    default:\n      throw new Error('invalid or unsupported key type');\n  }\n}; // Converts a public key object into a protobuf serialized public key\n\n\nexports.marshalPublicKey = (key, type) => {\n  type = (type || 'rsa').toLowerCase();\n\n  if (!isValidKeyType(type)) {\n    throw new Error('invalid or unsupported key type');\n  }\n\n  return key.bytes;\n}; // Converts a protobuf serialized private key into its\n// representative object\n\n\nexports.unmarshalPrivateKey = (buf, callback) => {\n  let decoded;\n\n  try {\n    decoded = keysPBM.PrivateKey.decode(buf);\n  } catch (err) {\n    return callback(err);\n  }\n\n  const data = decoded.Data;\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPrivateKey(data, callback);\n\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data, callback);\n\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data, callback);\n      } else {\n        return callback(new Error('secp256k1 support requires libp2p-crypto-secp256k1 package'));\n      }\n\n    default:\n      callback(new Error('invalid or unsupported key type'));\n  }\n}; // Converts a private key object into a protobuf serialized private key\n\n\nexports.marshalPrivateKey = (key, type) => {\n  type = (type || 'rsa').toLowerCase();\n\n  if (!isValidKeyType(type)) {\n    throw new Error('invalid or unsupported key type');\n  }\n\n  return key.bytes;\n};\n\nexports.import = (pem, password, callback) => {\n  try {\n    const key = forge.pki.decryptRsaPrivateKey(pem, password);\n\n    if (key === null) {\n      throw new Error('Cannot read the key, most likely the password is wrong or not a RSA key');\n    }\n\n    let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));\n    der = Buffer.from(der.getBytes(), 'binary');\n    return supportedKeys.rsa.unmarshalRsaPrivateKey(der, callback);\n  } catch (err) {\n    callback(err);\n  }\n};","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/libp2p-crypto/src/keys/index.js"],"names":["protobuf","require","keysPBM","forge","exports","module","supportedKeys","rsa","ed25519","secp256k1","isValidKeyType","keyType","key","toLowerCase","undefined","keyStretcher","generateEphemeralKeyPair","generateKeyPair","type","bits","cb","Error","generateKeyPairFromSeed","seed","unmarshalPublicKey","buf","decoded","PublicKey","decode","data","Data","Type","KeyType","RSA","unmarshalRsaPublicKey","Ed25519","unmarshalEd25519PublicKey","Secp256k1","unmarshalSecp256k1PublicKey","marshalPublicKey","bytes","unmarshalPrivateKey","callback","PrivateKey","err","unmarshalRsaPrivateKey","unmarshalEd25519PrivateKey","unmarshalSecp256k1PrivateKey","marshalPrivateKey","import","pem","password","pki","decryptRsaPrivateKey","der","asn1","toDer","privateKeyToAsn1","Buffer","from","getBytes"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst protobuf = require('protons')\r\nconst keysPBM = protobuf(require('./keys.proto'))\r\nrequire('node-forge/lib/asn1')\r\nrequire('node-forge/lib/rsa')\r\nrequire('node-forge/lib/pbe')\r\nconst forge = require('node-forge/lib/forge')\r\n\r\nexports = module.exports\r\n\r\nconst supportedKeys = {\r\n  rsa: require('./rsa-class'),\r\n  ed25519: require('./ed25519-class'),\r\n  secp256k1: require('libp2p-crypto-secp256k1')(keysPBM, require('../random-bytes'))\r\n}\r\n\r\nexports.supportedKeys = supportedKeys\r\nexports.keysPBM = keysPBM\r\n\r\nfunction isValidKeyType (keyType) {\r\n  const key = supportedKeys[keyType.toLowerCase()]\r\n  return key !== undefined\r\n}\r\n\r\nexports.keyStretcher = require('./key-stretcher')\r\nexports.generateEphemeralKeyPair = require('./ephemeral-keys')\r\n\r\n// Generates a keypair of the given type and bitsize\r\nexports.generateKeyPair = (type, bits, cb) => {\r\n  const key = supportedKeys[type.toLowerCase()]\r\n\r\n  if (!key) {\r\n    return cb(new Error('invalid or unsupported key type'))\r\n  }\r\n\r\n  key.generateKeyPair(bits, cb)\r\n}\r\n\r\n// Generates a keypair of the given type and bitsize\r\n// seed is a 32 byte uint8array\r\nexports.generateKeyPairFromSeed = (type, seed, bits, cb) => {\r\n  const key = supportedKeys[type.toLowerCase()]\r\n  if (!key) {\r\n    return cb(new Error('invalid or unsupported key type'))\r\n  }\r\n  if (type.toLowerCase() !== 'ed25519') {\r\n    return cb(new Error('Seed key derivation is unimplemented for RSA or secp256k1'))\r\n  }\r\n  key.generateKeyPairFromSeed(seed, bits, cb)\r\n}\r\n\r\n// Converts a protobuf serialized public key into its\r\n// representative object\r\nexports.unmarshalPublicKey = (buf) => {\r\n  const decoded = keysPBM.PublicKey.decode(buf)\r\n  const data = decoded.Data\r\n\r\n  switch (decoded.Type) {\r\n    case keysPBM.KeyType.RSA:\r\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data)\r\n    case keysPBM.KeyType.Ed25519:\r\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data)\r\n    case keysPBM.KeyType.Secp256k1:\r\n      if (supportedKeys.secp256k1) {\r\n        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data)\r\n      } else {\r\n        throw new Error('secp256k1 support requires libp2p-crypto-secp256k1 package')\r\n      }\r\n    default:\r\n      throw new Error('invalid or unsupported key type')\r\n  }\r\n}\r\n\r\n// Converts a public key object into a protobuf serialized public key\r\nexports.marshalPublicKey = (key, type) => {\r\n  type = (type || 'rsa').toLowerCase()\r\n  if (!isValidKeyType(type)) {\r\n    throw new Error('invalid or unsupported key type')\r\n  }\r\n\r\n  return key.bytes\r\n}\r\n\r\n// Converts a protobuf serialized private key into its\r\n// representative object\r\nexports.unmarshalPrivateKey = (buf, callback) => {\r\n  let decoded\r\n  try {\r\n    decoded = keysPBM.PrivateKey.decode(buf)\r\n  } catch (err) {\r\n    return callback(err)\r\n  }\r\n\r\n  const data = decoded.Data\r\n\r\n  switch (decoded.Type) {\r\n    case keysPBM.KeyType.RSA:\r\n      return supportedKeys.rsa.unmarshalRsaPrivateKey(data, callback)\r\n    case keysPBM.KeyType.Ed25519:\r\n      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data, callback)\r\n    case keysPBM.KeyType.Secp256k1:\r\n      if (supportedKeys.secp256k1) {\r\n        return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data, callback)\r\n      } else {\r\n        return callback(new Error('secp256k1 support requires libp2p-crypto-secp256k1 package'))\r\n      }\r\n    default:\r\n      callback(new Error('invalid or unsupported key type'))\r\n  }\r\n}\r\n\r\n// Converts a private key object into a protobuf serialized private key\r\nexports.marshalPrivateKey = (key, type) => {\r\n  type = (type || 'rsa').toLowerCase()\r\n  if (!isValidKeyType(type)) {\r\n    throw new Error('invalid or unsupported key type')\r\n  }\r\n\r\n  return key.bytes\r\n}\r\n\r\nexports.import = (pem, password, callback) => {\r\n  try {\r\n    const key = forge.pki.decryptRsaPrivateKey(pem, password)\r\n    if (key === null) {\r\n      throw new Error('Cannot read the key, most likely the password is wrong or not a RSA key')\r\n    }\r\n    let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key))\r\n    der = Buffer.from(der.getBytes(), 'binary')\r\n    return supportedKeys.rsa.unmarshalRsaPrivateKey(der, callback)\r\n  } catch (err) {\r\n    callback(err)\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}