{"ast":null,"code":"'use strict';\n\nconst base58 = require('bs58');\n\nconst multihash = require('multihashes');\n\nconst multibase = require('multibase');\n\nconst Multiaddr = require('multiaddr');\n\nconst mafmt = require('mafmt');\n\nconst CID = require('cids');\n\nconst urlPattern = /^https?:\\/\\/[^/]+\\/(ip(f|n)s)\\/((\\w+).*)/;\nconst pathPattern = /^\\/(ip(f|n)s)\\/((\\w+).*)/;\nconst defaultProtocolMatch = 1;\nconst defaultHashMath = 4;\nconst fqdnPattern = /^https?:\\/\\/([^/]+)\\.(ip(?:f|n)s)\\.[^/]+/;\nconst fqdnHashMatch = 1;\nconst fqdnProtocolMatch = 2;\n\nfunction isMultihash(hash) {\n  const formatted = convertToString(hash);\n\n  try {\n    const buffer = Buffer.from(base58.decode(formatted));\n    multihash.decode(buffer);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isMultibase(hash) {\n  try {\n    return multibase.isEncoded(hash);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isCID(hash) {\n  try {\n    new CID(hash); // eslint-disable-line no-new\n\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isMultiaddr(input) {\n  if (!input) return false;\n  if (Multiaddr.isMultiaddr(input)) return true;\n\n  try {\n    new Multiaddr(input); // eslint-disable-line no-new\n\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isPeerMultiaddr(input) {\n  return isMultiaddr(input) && mafmt.IPFS.matches(input);\n}\n\nfunction isIpfs(input, pattern) {\n  let protocolMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultProtocolMatch;\n  let hashMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultHashMath;\n  const formatted = convertToString(input);\n\n  if (!formatted) {\n    return false;\n  }\n\n  const match = formatted.match(pattern);\n\n  if (!match) {\n    return false;\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false;\n  }\n\n  let hash = match[hashMatch];\n\n  if (hash && pattern === fqdnPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    hash = hash.toLowerCase();\n  }\n\n  return isCID(hash);\n}\n\nfunction isIpns(input, pattern) {\n  let protocolMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultProtocolMatch;\n  let hashMatch = arguments.length > 3 ? arguments[3] : undefined;\n  const formatted = convertToString(input);\n\n  if (!formatted) {\n    return false;\n  }\n\n  const match = formatted.match(pattern);\n\n  if (!match) {\n    return false;\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false;\n  }\n\n  if (hashMatch && pattern === fqdnPattern) {\n    let hash = match[hashMatch]; // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n\n    hash = hash.toLowerCase();\n    return isCID(hash);\n  }\n\n  return true;\n}\n\nfunction isString(input) {\n  return typeof input === 'string';\n}\n\nfunction convertToString(input) {\n  if (Buffer.isBuffer(input)) {\n    return base58.encode(input);\n  }\n\n  if (isString(input)) {\n    return input;\n  }\n\n  return false;\n}\n\nconst ipfsSubdomain = url => isIpfs(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch);\n\nconst ipnsSubdomain = url => isIpns(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch);\n\nmodule.exports = {\n  multihash: isMultihash,\n  multiaddr: isMultiaddr,\n  peerMultiaddr: isPeerMultiaddr,\n  cid: isCID,\n  base32cid: cid => isMultibase(cid) === 'base32' && isCID(cid),\n  ipfsSubdomain: ipfsSubdomain,\n  ipnsSubdomain: ipnsSubdomain,\n  subdomain: url => ipfsSubdomain(url) || ipnsSubdomain(url),\n  subdomainPattern: fqdnPattern,\n  ipfsUrl: url => isIpfs(url, urlPattern),\n  ipnsUrl: url => isIpns(url, urlPattern),\n  url: url => isIpfs(url, urlPattern) || isIpns(url, urlPattern),\n  urlPattern: urlPattern,\n  ipfsPath: path => isIpfs(path, pathPattern),\n  ipnsPath: path => isIpns(path, pathPattern),\n  path: path => isIpfs(path, pathPattern) || isIpns(path, pathPattern),\n  pathPattern: pathPattern,\n  urlOrPath: x => isIpfs(x, urlPattern) || isIpns(x, urlPattern) || isIpfs(x, pathPattern) || isIpns(x, pathPattern),\n  cidPath: path => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)\n};","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/is-ipfs/src/index.js"],"names":["base58","require","multihash","multibase","Multiaddr","mafmt","CID","urlPattern","pathPattern","defaultProtocolMatch","defaultHashMath","fqdnPattern","fqdnHashMatch","fqdnProtocolMatch","isMultihash","hash","formatted","convertToString","buffer","Buffer","from","decode","e","isMultibase","isEncoded","isCID","isMultiaddr","input","isPeerMultiaddr","IPFS","matches","isIpfs","pattern","protocolMatch","hashMatch","match","toLowerCase","isIpns","isString","isBuffer","encode","ipfsSubdomain","url","ipnsSubdomain","module","exports","multiaddr","peerMultiaddr","cid","base32cid","subdomain","subdomainPattern","ipfsUrl","ipnsUrl","ipfsPath","path","ipnsPath","urlOrPath","x","cidPath"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst base58 = require('bs58')\r\nconst multihash = require('multihashes')\r\nconst multibase = require('multibase')\r\nconst Multiaddr = require('multiaddr')\r\nconst mafmt = require('mafmt')\r\nconst CID = require('cids')\r\n\r\nconst urlPattern = /^https?:\\/\\/[^/]+\\/(ip(f|n)s)\\/((\\w+).*)/\r\nconst pathPattern = /^\\/(ip(f|n)s)\\/((\\w+).*)/\r\nconst defaultProtocolMatch = 1\r\nconst defaultHashMath = 4\r\n\r\nconst fqdnPattern = /^https?:\\/\\/([^/]+)\\.(ip(?:f|n)s)\\.[^/]+/\r\nconst fqdnHashMatch = 1\r\nconst fqdnProtocolMatch = 2\r\n\r\nfunction isMultihash (hash) {\r\n  const formatted = convertToString(hash)\r\n  try {\r\n    const buffer = Buffer.from(base58.decode(formatted))\r\n    multihash.decode(buffer)\r\n    return true\r\n  } catch (e) {\r\n    return false\r\n  }\r\n}\r\n\r\nfunction isMultibase (hash) {\r\n  try {\r\n    return multibase.isEncoded(hash)\r\n  } catch (e) {\r\n    return false\r\n  }\r\n}\r\n\r\nfunction isCID (hash) {\r\n  try {\r\n    new CID(hash) // eslint-disable-line no-new\r\n    return true\r\n  } catch (e) {\r\n    return false\r\n  }\r\n}\r\n\r\nfunction isMultiaddr (input) {\r\n  if (!input) return false\r\n  if (Multiaddr.isMultiaddr(input)) return true\r\n  try {\r\n    new Multiaddr(input) // eslint-disable-line no-new\r\n    return true\r\n  } catch (e) {\r\n    return false\r\n  }\r\n}\r\n\r\nfunction isPeerMultiaddr (input) {\r\n  return isMultiaddr(input) && mafmt.IPFS.matches(input)\r\n}\r\n\r\nfunction isIpfs (input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\r\n  const formatted = convertToString(input)\r\n  if (!formatted) {\r\n    return false\r\n  }\r\n\r\n  const match = formatted.match(pattern)\r\n  if (!match) {\r\n    return false\r\n  }\r\n\r\n  if (match[protocolMatch] !== 'ipfs') {\r\n    return false\r\n  }\r\n\r\n  let hash = match[hashMatch]\r\n\r\n  if (hash && pattern === fqdnPattern) {\r\n    // when doing checks for subdomain context\r\n    // ensure hash is case-insensitive\r\n    // (browsers force-lowercase authority compotent anyway)\r\n    hash = hash.toLowerCase()\r\n  }\r\n\r\n  return isCID(hash)\r\n}\r\n\r\nfunction isIpns (input, pattern, protocolMatch = defaultProtocolMatch, hashMatch) {\r\n  const formatted = convertToString(input)\r\n  if (!formatted) {\r\n    return false\r\n  }\r\n  const match = formatted.match(pattern)\r\n  if (!match) {\r\n    return false\r\n  }\r\n\r\n  if (match[protocolMatch] !== 'ipns') {\r\n    return false\r\n  }\r\n\r\n  if (hashMatch && pattern === fqdnPattern) {\r\n    let hash = match[hashMatch]\r\n    // when doing checks for subdomain context\r\n    // ensure hash is case-insensitive\r\n    // (browsers force-lowercase authority compotent anyway)\r\n    hash = hash.toLowerCase()\r\n    return isCID(hash)\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nfunction isString (input) {\r\n  return typeof input === 'string'\r\n}\r\n\r\nfunction convertToString (input) {\r\n  if (Buffer.isBuffer(input)) {\r\n    return base58.encode(input)\r\n  }\r\n\r\n  if (isString(input)) {\r\n    return input\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nconst ipfsSubdomain = (url) => isIpfs(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch)\r\nconst ipnsSubdomain = (url) => isIpns(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch)\r\n\r\nmodule.exports = {\r\n  multihash: isMultihash,\r\n  multiaddr: isMultiaddr,\r\n  peerMultiaddr: isPeerMultiaddr,\r\n  cid: isCID,\r\n  base32cid: (cid) => (isMultibase(cid) === 'base32' && isCID(cid)),\r\n  ipfsSubdomain: ipfsSubdomain,\r\n  ipnsSubdomain: ipnsSubdomain,\r\n  subdomain: (url) => (ipfsSubdomain(url) || ipnsSubdomain(url)),\r\n  subdomainPattern: fqdnPattern,\r\n  ipfsUrl: (url) => isIpfs(url, urlPattern),\r\n  ipnsUrl: (url) => isIpns(url, urlPattern),\r\n  url: (url) => (isIpfs(url, urlPattern) || isIpns(url, urlPattern)),\r\n  urlPattern: urlPattern,\r\n  ipfsPath: (path) => isIpfs(path, pathPattern),\r\n  ipnsPath: (path) => isIpns(path, pathPattern),\r\n  path: (path) => (isIpfs(path, pathPattern) || isIpns(path, pathPattern)),\r\n  pathPattern: pathPattern,\r\n  urlOrPath: (x) => (isIpfs(x, urlPattern) || isIpns(x, urlPattern) || isIpfs(x, pathPattern) || isIpns(x, pathPattern)),\r\n  cidPath: path => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)\r\n}\r\n"]},"metadata":{},"sourceType":"script"}