{"ast":null,"code":"var capability = require('./capability');\n\nvar inherits = require('inherits');\n\nvar stream = require('readable-stream');\n\nvar IncomingMessage = function (response, mode, fetchTimer) {\n  stream.Readable.call(this);\n  this._mode = mode;\n  this.headers = {};\n  this.rawHeaders = [];\n  this.trailers = {};\n  this.rawTrailers = []; // Fake the 'close' event, but only once 'end' fires\n\n  this.on('end', () => {\n    // The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n    process.nextTick(() => this.emit('close'));\n  });\n  this._fetchResponse = response;\n  this.url = response.url;\n  this.statusCode = response.status;\n  this.statusMessage = response.statusText;\n  response.headers.forEach((header, key) => {\n    this.headers[key.toLowerCase()] = header;\n    this.rawHeaders.push(key, header);\n  });\n\n  if (capability.writableStream) {\n    var writable = new WritableStream({\n      write: chunk => {\n        return new Promise((resolve, reject) => {\n          if (this._destroyed) {\n            reject();\n          } else if (this.push(Buffer.from(chunk))) {\n            resolve();\n          } else {\n            this._resumeFetch = resolve;\n          }\n        });\n      },\n      close: () => {\n        clearTimeout(fetchTimer);\n\n        if (!this._destroyed) {\n          this.push(null);\n        }\n      },\n      abort: err => {\n        if (!this._destroyed) {\n          this.emit('error', err);\n        }\n      }\n    });\n\n    try {\n      response.body.pipeTo(writable).catch(err => {\n        console.log(err);\n        self.clearTimeout(fetchTimer);\n\n        if (!this._destroyed) {\n          this.emit('error', err);\n        }\n      });\n      return;\n    } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\n  } // fallback for when writableStream or pipeTo aren't available\n\n\n  var reader = response.body.getReader();\n\n  function read(context) {\n    reader.read().then(result => {\n      if (context._destroyed) {\n        return;\n      }\n\n      if (result.done) {\n        clearTimeout(fetchTimer);\n        context.push(null);\n        return;\n      }\n\n      context.push(Buffer.from(result.value));\n      read(context);\n    }).catch(err => {\n      clearTimeout(fetchTimer);\n\n      if (!context._destroyed) {\n        context.emit('error', err);\n      }\n    });\n  }\n\n  read(this);\n};\n\ninherits(IncomingMessage, stream.Readable);\n\nIncomingMessage.prototype._read = function () {\n  var resolve = this._resumeFetch;\n\n  if (resolve) {\n    this._resumeFetch = null;\n    resolve();\n  }\n};\n\nmodule.exports = IncomingMessage;","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/iso-stream-http/lib/incoming-message.js"],"names":["capability","require","inherits","stream","IncomingMessage","response","mode","fetchTimer","Readable","call","_mode","headers","rawHeaders","trailers","rawTrailers","on","process","nextTick","emit","_fetchResponse","url","statusCode","status","statusMessage","statusText","forEach","header","key","toLowerCase","push","writableStream","writable","WritableStream","write","chunk","Promise","resolve","reject","_destroyed","Buffer","from","_resumeFetch","close","clearTimeout","abort","err","body","pipeTo","catch","console","log","self","e","reader","getReader","read","context","then","result","done","value","prototype","_read","module","exports"],"mappings":"AAAA,IAAIA,UAAU,GAAGC,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AACA,IAAIE,MAAM,GAAGF,OAAO,CAAC,iBAAD,CAApB;;AAEA,IAAIG,eAAe,GAAG,UAAUC,QAAV,EAAoBC,IAApB,EAA0BC,UAA1B,EAAsC;AAC3DJ,EAAAA,MAAM,CAACK,QAAP,CAAgBC,IAAhB,CAAqB,IAArB;AAEA,OAAKC,KAAL,GAAaJ,IAAb;AACA,OAAKK,OAAL,GAAe,EAAf;AACA,OAAKC,UAAL,GAAkB,EAAlB;AACA,OAAKC,QAAL,GAAgB,EAAhB;AACA,OAAKC,WAAL,GAAmB,EAAnB,CAP2D,CAS3D;;AACA,OAAKC,EAAL,CAAQ,KAAR,EAAgB,MAAM;AACrB;AACAC,IAAAA,OAAO,CAACC,QAAR,CAAiB,MAAK,KAAKC,IAAL,CAAU,OAAV,CAAtB;AACA,GAHD;AAKA,OAAKC,cAAL,GAAsBd,QAAtB;AAEA,OAAKe,GAAL,GAAWf,QAAQ,CAACe,GAApB;AACA,OAAKC,UAAL,GAAkBhB,QAAQ,CAACiB,MAA3B;AACA,OAAKC,aAAL,GAAqBlB,QAAQ,CAACmB,UAA9B;AAEAnB,EAAAA,QAAQ,CAACM,OAAT,CAAiBc,OAAjB,CAAyB,CAACC,MAAD,EAASC,GAAT,KAAiB;AACzC,SAAKhB,OAAL,CAAagB,GAAG,CAACC,WAAJ,EAAb,IAAkCF,MAAlC;AACA,SAAKd,UAAL,CAAgBiB,IAAhB,CAAqBF,GAArB,EAA0BD,MAA1B;AACA,GAHD;;AAKA,MAAI1B,UAAU,CAAC8B,cAAf,EAA+B;AAC9B,QAAIC,QAAQ,GAAG,IAAIC,cAAJ,CAAmB;AACjCC,MAAAA,KAAK,EAAEC,KAAK,IAAI;AACf,eAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACvC,cAAI,KAAKC,UAAT,EAAqB;AACpBD,YAAAA,MAAM;AACN,WAFD,MAEO,IAAG,KAAKR,IAAL,CAAUU,MAAM,CAACC,IAAP,CAAYN,KAAZ,CAAV,CAAH,EAAkC;AACxCE,YAAAA,OAAO;AACP,WAFM,MAEA;AACN,iBAAKK,YAAL,GAAoBL,OAApB;AACA;AACD,SARM,CAAP;AASA,OAXgC;AAYjCM,MAAAA,KAAK,EAAE,MAAM;AACZC,QAAAA,YAAY,CAACpC,UAAD,CAAZ;;AACA,YAAI,CAAC,KAAK+B,UAAV,EAAqB;AACpB,eAAKT,IAAL,CAAU,IAAV;AACA;AACD,OAjBgC;AAkBjCe,MAAAA,KAAK,EAAEC,GAAG,IAAI;AACb,YAAI,CAAC,KAAKP,UAAV,EAAqB;AACpB,eAAKpB,IAAL,CAAU,OAAV,EAAmB2B,GAAnB;AACA;AACD;AAtBgC,KAAnB,CAAf;;AAyBA,QAAI;AACHxC,MAAAA,QAAQ,CAACyC,IAAT,CACEC,MADF,CACShB,QADT,EAEEiB,KAFF,CAEQH,GAAG,IAAI;AACbI,QAAAA,OAAO,CAACC,GAAR,CAAYL,GAAZ;AACAM,QAAAA,IAAI,CAACR,YAAL,CAAkBpC,UAAlB;;AACA,YAAI,CAAC,KAAK+B,UAAV,EAAqB;AACpB,eAAKpB,IAAL,CAAU,OAAV,EAAmB2B,GAAnB;AACA;AACD,OARF;AASA;AACA,KAXD,CAWE,OAAOO,CAAP,EAAU,CAAE,CArCgB,CAqCf;;AACf,GAhE0D,CAiE3D;;;AACA,MAAIC,MAAM,GAAGhD,QAAQ,CAACyC,IAAT,CAAcQ,SAAd,EAAb;;AAEA,WAASC,IAAT,CAAeC,OAAf,EAAwB;AACvBH,IAAAA,MAAM,CAACE,IAAP,GACCE,IADD,CACMC,MAAM,IAAI;AACf,UAAIF,OAAO,CAAClB,UAAZ,EAAuB;AACtB;AACA;;AACD,UAAIoB,MAAM,CAACC,IAAX,EAAiB;AAChBhB,QAAAA,YAAY,CAACpC,UAAD,CAAZ;AACAiD,QAAAA,OAAO,CAAC3B,IAAR,CAAa,IAAb;AACA;AACA;;AACD2B,MAAAA,OAAO,CAAC3B,IAAR,CAAaU,MAAM,CAACC,IAAP,CAAYkB,MAAM,CAACE,KAAnB,CAAb;AACAL,MAAAA,IAAI,CAACC,OAAD,CAAJ;AACA,KAZD,EAaCR,KAbD,CAaOH,GAAG,IAAI;AACbF,MAAAA,YAAY,CAACpC,UAAD,CAAZ;;AACA,UAAI,CAACiD,OAAO,CAAClB,UAAb,EAAwB;AACvBkB,QAAAA,OAAO,CAACtC,IAAR,CAAa,OAAb,EAAsB2B,GAAtB;AACA;AACD,KAlBD;AAmBA;;AAEDU,EAAAA,IAAI,CAAC,IAAD,CAAJ;AAEA,CA5FD;;AA8FArD,QAAQ,CAACE,eAAD,EAAkBD,MAAM,CAACK,QAAzB,CAAR;;AAEAJ,eAAe,CAACyD,SAAhB,CAA0BC,KAA1B,GAAkC,YAAY;AAC7C,MAAI1B,OAAO,GAAG,KAAKK,YAAnB;;AACA,MAAIL,OAAJ,EAAa;AACZ,SAAKK,YAAL,GAAoB,IAApB;AACAL,IAAAA,OAAO;AACP;AACD,CAND;;AAQA2B,MAAM,CAACC,OAAP,GAAiB5D,eAAjB","sourcesContent":["var capability = require('./capability')\r\nvar inherits = require('inherits')\r\nvar stream = require('readable-stream')\r\n\r\nvar IncomingMessage = function (response, mode, fetchTimer) {\r\n\tstream.Readable.call(this)\r\n\r\n\tthis._mode = mode\r\n\tthis.headers = {}\r\n\tthis.rawHeaders = []\r\n\tthis.trailers = {}\r\n\tthis.rawTrailers = []\r\n\r\n\t// Fake the 'close' event, but only once 'end' fires\r\n\tthis.on('end',  () => {\r\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\r\n\t\tprocess.nextTick(() =>this.emit('close'))\r\n\t})\r\n\r\n\tthis._fetchResponse = response\r\n\r\n\tthis.url = response.url\r\n\tthis.statusCode = response.status\r\n\tthis.statusMessage = response.statusText\r\n\t\r\n\tresponse.headers.forEach((header, key) => {\r\n\t\tthis.headers[key.toLowerCase()] = header\r\n\t\tthis.rawHeaders.push(key, header)\r\n\t})\r\n\r\n\tif (capability.writableStream) {\r\n\t\tvar writable = new WritableStream({\r\n\t\t\twrite: chunk => {\r\n\t\t\t\treturn new Promise((resolve, reject) => {\r\n\t\t\t\t\tif (this._destroyed) {\r\n\t\t\t\t\t\treject()\r\n\t\t\t\t\t} else if(this.push(Buffer.from(chunk))) {\r\n\t\t\t\t\t\tresolve()\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis._resumeFetch = resolve\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tclose: () => {\r\n\t\t\t\tclearTimeout(fetchTimer)\r\n\t\t\t\tif (!this._destroyed){\r\n\t\t\t\t\tthis.push(null)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tabort: err => {\r\n\t\t\t\tif (!this._destroyed){\r\n\t\t\t\t\tthis.emit('error', err)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\ttry {\r\n\t\t\tresponse.body\r\n\t\t\t\t.pipeTo(writable)\r\n\t\t\t\t.catch(err => {\r\n\t\t\t\t\tconsole.log(err);\r\n\t\t\t\t\tself.clearTimeout(fetchTimer)\r\n\t\t\t\t\tif (!this._destroyed){\r\n\t\t\t\t\t\tthis.emit('error', err)\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\treturn\r\n\t\t} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\r\n\t}\r\n\t// fallback for when writableStream or pipeTo aren't available\r\n\tvar reader = response.body.getReader()\r\n\t\r\n\tfunction read (context) {\r\n\t\treader.read()\r\n\t\t.then(result => {\r\n\t\t\tif (context._destroyed){\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (result.done) {\r\n\t\t\t\tclearTimeout(fetchTimer)\r\n\t\t\t\tcontext.push(null)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tcontext.push(Buffer.from(result.value))\r\n\t\t\tread(context)\r\n\t\t})\r\n\t\t.catch(err => {\r\n\t\t\tclearTimeout(fetchTimer)\r\n\t\t\tif (!context._destroyed){\r\n\t\t\t\tcontext.emit('error', err)\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tread(this)\r\n\t\r\n}\r\n\r\ninherits(IncomingMessage, stream.Readable)\r\n\r\nIncomingMessage.prototype._read = function () {\r\n\tvar resolve = this._resumeFetch\r\n\tif (resolve) {\r\n\t\tthis._resumeFetch = null\r\n\t\tresolve()\r\n\t}\r\n}\r\n\r\nmodule.exports = IncomingMessage"]},"metadata":{},"sourceType":"script"}