{"ast":null,"code":"/* eslint-disable guard-for-in */\n\n/**\r\n * Multihash implementation in JavaScript.\r\n *\r\n * @module multihash\r\n */\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst multibase = require('multibase');\n\nconst varint = require('varint');\n\nconst {\n  names\n} = require('./constants');\n\nconst codes = {};\n\nfor (const key in names) {\n  codes[names[key]] = key;\n}\n\nexports.names = names;\nexports.codes = Object.freeze(codes);\n/**\r\n * Convert the given multihash to a hex encoded string.\r\n *\r\n * @param {Buffer} hash\r\n * @returns {string}\r\n */\n\nexports.toHexString = function toHexString(hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer');\n  }\n\n  return hash.toString('hex');\n};\n/**\r\n * Convert the given hex encoded string to a multihash.\r\n *\r\n * @param {string} hash\r\n * @returns {Buffer}\r\n */\n\n\nexports.fromHexString = function fromHexString(hash) {\n  return Buffer.from(hash, 'hex');\n};\n/**\r\n * Convert the given multihash to a base58 encoded string.\r\n *\r\n * @param {Buffer} hash\r\n * @returns {string}\r\n */\n\n\nexports.toB58String = function toB58String(hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer');\n  }\n\n  return multibase.encode('base58btc', hash).toString().slice(1);\n};\n/**\r\n * Convert the given base58 encoded string to a multihash.\r\n *\r\n * @param {string|Buffer} hash\r\n * @returns {Buffer}\r\n */\n\n\nexports.fromB58String = function fromB58String(hash) {\n  let encoded = hash;\n\n  if (Buffer.isBuffer(hash)) {\n    encoded = hash.toString();\n  }\n\n  return multibase.decode('z' + encoded);\n};\n/**\r\n * Decode a hash from the given multihash.\r\n *\r\n * @param {Buffer} buf\r\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\r\n */\n\n\nexports.decode = function decode(buf) {\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error('multihash must be a Buffer');\n  }\n\n  if (buf.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.');\n  }\n\n  const code = varint.decode(buf);\n\n  if (!exports.isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);\n  }\n\n  buf = buf.slice(varint.decode.bytes);\n  const len = varint.decode(buf);\n\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`);\n  }\n\n  buf = buf.slice(varint.decode.bytes);\n\n  if (buf.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`);\n  }\n\n  return {\n    code,\n    name: codes[code],\n    length: len,\n    digest: buf\n  };\n};\n/**\r\n *  Encode a hash digest along with the specified function code.\r\n *\r\n * > **Note:** the length is derived from the length of the digest itself.\r\n *\r\n * @param {Buffer} digest\r\n * @param {string|number} code\r\n * @param {number} [length]\r\n * @returns {Buffer}\r\n */\n\n\nexports.encode = function encode(digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code');\n  } // ensure it's a hashfunction code.\n\n\n  const hashfn = exports.coerceCode(code);\n\n  if (!Buffer.isBuffer(digest)) {\n    throw new Error('digest should be a Buffer');\n  }\n\n  if (length == null) {\n    length = digest.length;\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.');\n  }\n\n  return Buffer.concat([Buffer.from(varint.encode(hashfn)), Buffer.from(varint.encode(length)), digest]);\n};\n/**\r\n * Converts a hash function name into the matching code.\r\n * If passed a number it will return the number if it's a valid code.\r\n * @param {string|number} name\r\n * @returns {number}\r\n */\n\n\nexports.coerceCode = function coerceCode(name) {\n  let code = name;\n\n  if (typeof name === 'string') {\n    if (names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`);\n    }\n\n    code = names[name];\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`);\n  }\n\n  if (codes[code] === undefined && !exports.isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`);\n  }\n\n  return code;\n};\n/**\r\n * Checks wether a code is part of the app range\r\n *\r\n * @param {number} code\r\n * @returns {boolean}\r\n */\n\n\nexports.isAppCode = function appCode(code) {\n  return code > 0 && code < 0x10;\n};\n/**\r\n * Checks whether a multihash code is valid.\r\n *\r\n * @param {number} code\r\n * @returns {boolean}\r\n */\n\n\nexports.isValidCode = function validCode(code) {\n  if (exports.isAppCode(code)) {\n    return true;\n  }\n\n  if (codes[code]) {\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\r\n *\r\n * @param {Buffer} multihash\r\n * @returns {undefined}\r\n * @throws {Error}\r\n */\n\n\nfunction validate(multihash) {\n  exports.decode(multihash); // throws if bad.\n}\n\nexports.validate = validate;\n/**\r\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\r\n *\r\n * @param {Buffer} multihash\r\n * @returns {undefined}\r\n * @throws {Error}\r\n */\n\nexports.prefix = function prefix(multihash) {\n  validate(multihash);\n  return multihash.slice(0, 2);\n};","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/multihashing-async/node_modules/multihashes/src/index.js"],"names":["Buffer","require","multibase","varint","names","codes","key","exports","Object","freeze","toHexString","hash","isBuffer","Error","toString","fromHexString","from","toB58String","encode","slice","fromB58String","encoded","decode","buf","length","code","isValidCode","bytes","len","name","digest","undefined","hashfn","coerceCode","concat","isAppCode","appCode","validCode","validate","multihash","prefix"],"mappings":"AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAYH,OAAO,CAAC,aAAD,CAAzB;;AAEA,MAAMI,KAAK,GAAG,EAAd;;AAEA,KAAK,MAAMC,GAAX,IAAkBF,KAAlB,EAAyB;AACvBC,EAAAA,KAAK,CAACD,KAAK,CAACE,GAAD,CAAN,CAAL,GAAoBA,GAApB;AACD;;AACDC,OAAO,CAACH,KAAR,GAAgBA,KAAhB;AACAG,OAAO,CAACF,KAAR,GAAgBG,MAAM,CAACC,MAAP,CAAcJ,KAAd,CAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAE,OAAO,CAACG,WAAR,GAAsB,SAASA,WAAT,CAAsBC,IAAtB,EAA4B;AAChD,MAAI,CAACX,MAAM,CAACY,QAAP,CAAgBD,IAAhB,CAAL,EAA4B;AAC1B,UAAM,IAAIE,KAAJ,CAAU,yBAAV,CAAN;AACD;;AAED,SAAOF,IAAI,CAACG,QAAL,CAAc,KAAd,CAAP;AACD,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;;;AACAP,OAAO,CAACQ,aAAR,GAAwB,SAASA,aAAT,CAAwBJ,IAAxB,EAA8B;AACpD,SAAOX,MAAM,CAACgB,IAAP,CAAYL,IAAZ,EAAkB,KAAlB,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AACAJ,OAAO,CAACU,WAAR,GAAsB,SAASA,WAAT,CAAsBN,IAAtB,EAA4B;AAChD,MAAI,CAACX,MAAM,CAACY,QAAP,CAAgBD,IAAhB,CAAL,EAA4B;AAC1B,UAAM,IAAIE,KAAJ,CAAU,yBAAV,CAAN;AACD;;AAED,SAAOX,SAAS,CAACgB,MAAV,CAAiB,WAAjB,EAA8BP,IAA9B,EAAoCG,QAApC,GAA+CK,KAA/C,CAAqD,CAArD,CAAP;AACD,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;;;AACAZ,OAAO,CAACa,aAAR,GAAwB,SAASA,aAAT,CAAwBT,IAAxB,EAA8B;AACpD,MAAIU,OAAO,GAAGV,IAAd;;AACA,MAAIX,MAAM,CAACY,QAAP,CAAgBD,IAAhB,CAAJ,EAA2B;AACzBU,IAAAA,OAAO,GAAGV,IAAI,CAACG,QAAL,EAAV;AACD;;AAED,SAAOZ,SAAS,CAACoB,MAAV,CAAiB,MAAMD,OAAvB,CAAP;AACD,CAPD;AASA;AACA;AACA;AACA;AACA;AACA;;;AACAd,OAAO,CAACe,MAAR,GAAiB,SAASA,MAAT,CAAiBC,GAAjB,EAAsB;AACrC,MAAI,CAAEvB,MAAM,CAACY,QAAP,CAAgBW,GAAhB,CAAN,EAA6B;AAC3B,UAAM,IAAIV,KAAJ,CAAU,4BAAV,CAAN;AACD;;AAED,MAAIU,GAAG,CAACC,MAAJ,GAAa,CAAjB,EAAoB;AAClB,UAAM,IAAIX,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAED,QAAMY,IAAI,GAAGtB,MAAM,CAACmB,MAAP,CAAcC,GAAd,CAAb;;AACA,MAAI,CAAChB,OAAO,CAACmB,WAAR,CAAoBD,IAApB,CAAL,EAAgC;AAC9B,UAAM,IAAIZ,KAAJ,CAAW,sCAAqCY,IAAI,CAACX,QAAL,CAAc,EAAd,CAAkB,EAAlE,CAAN;AACD;;AACDS,EAAAA,GAAG,GAAGA,GAAG,CAACJ,KAAJ,CAAUhB,MAAM,CAACmB,MAAP,CAAcK,KAAxB,CAAN;AAEA,QAAMC,GAAG,GAAGzB,MAAM,CAACmB,MAAP,CAAcC,GAAd,CAAZ;;AACA,MAAIK,GAAG,GAAG,CAAV,EAAa;AACX,UAAM,IAAIf,KAAJ,CAAW,6BAA4Be,GAAI,EAA3C,CAAN;AACD;;AACDL,EAAAA,GAAG,GAAGA,GAAG,CAACJ,KAAJ,CAAUhB,MAAM,CAACmB,MAAP,CAAcK,KAAxB,CAAN;;AAEA,MAAIJ,GAAG,CAACC,MAAJ,KAAeI,GAAnB,EAAwB;AACtB,UAAM,IAAIf,KAAJ,CAAW,oCAAmCU,GAAG,CAACT,QAAJ,CAAa,KAAb,CAAoB,EAAlE,CAAN;AACD;;AAED,SAAO;AACLW,IAAAA,IADK;AAELI,IAAAA,IAAI,EAAExB,KAAK,CAACoB,IAAD,CAFN;AAGLD,IAAAA,MAAM,EAAEI,GAHH;AAILE,IAAAA,MAAM,EAAEP;AAJH,GAAP;AAMD,CA/BD;AAiCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAhB,OAAO,CAACW,MAAR,GAAiB,SAASA,MAAT,CAAiBY,MAAjB,EAAyBL,IAAzB,EAA+BD,MAA/B,EAAuC;AACtD,MAAI,CAACM,MAAD,IAAWL,IAAI,KAAKM,SAAxB,EAAmC;AACjC,UAAM,IAAIlB,KAAJ,CAAU,2DAAV,CAAN;AACD,GAHqD,CAKtD;;;AACA,QAAMmB,MAAM,GAAGzB,OAAO,CAAC0B,UAAR,CAAmBR,IAAnB,CAAf;;AAEA,MAAI,CAAEzB,MAAM,CAACY,QAAP,CAAgBkB,MAAhB,CAAN,EAAgC;AAC9B,UAAM,IAAIjB,KAAJ,CAAU,2BAAV,CAAN;AACD;;AAED,MAAIW,MAAM,IAAI,IAAd,EAAoB;AAClBA,IAAAA,MAAM,GAAGM,MAAM,CAACN,MAAhB;AACD;;AAED,MAAIA,MAAM,IAAIM,MAAM,CAACN,MAAP,KAAkBA,MAAhC,EAAwC;AACtC,UAAM,IAAIX,KAAJ,CAAU,oDAAV,CAAN;AACD;;AAED,SAAOb,MAAM,CAACkC,MAAP,CAAc,CACnBlC,MAAM,CAACgB,IAAP,CAAYb,MAAM,CAACe,MAAP,CAAcc,MAAd,CAAZ,CADmB,EAEnBhC,MAAM,CAACgB,IAAP,CAAYb,MAAM,CAACe,MAAP,CAAcM,MAAd,CAAZ,CAFmB,EAGnBM,MAHmB,CAAd,CAAP;AAKD,CAzBD;AA2BA;AACA;AACA;AACA;AACA;AACA;;;AACAvB,OAAO,CAAC0B,UAAR,GAAqB,SAASA,UAAT,CAAqBJ,IAArB,EAA2B;AAC9C,MAAIJ,IAAI,GAAGI,IAAX;;AAEA,MAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAIzB,KAAK,CAACyB,IAAD,CAAL,KAAgBE,SAApB,EAA+B;AAC7B,YAAM,IAAIlB,KAAJ,CAAW,qCAAoCgB,IAAK,EAApD,CAAN;AACD;;AACDJ,IAAAA,IAAI,GAAGrB,KAAK,CAACyB,IAAD,CAAZ;AACD;;AAED,MAAI,OAAOJ,IAAP,KAAgB,QAApB,EAA8B;AAC5B,UAAM,IAAIZ,KAAJ,CAAW,+CAA8CY,IAAK,EAA9D,CAAN;AACD;;AAED,MAAIpB,KAAK,CAACoB,IAAD,CAAL,KAAgBM,SAAhB,IAA6B,CAACxB,OAAO,CAAC4B,SAAR,CAAkBV,IAAlB,CAAlC,EAA2D;AACzD,UAAM,IAAIZ,KAAJ,CAAW,+BAA8BY,IAAK,EAA9C,CAAN;AACD;;AAED,SAAOA,IAAP;AACD,CAnBD;AAqBA;AACA;AACA;AACA;AACA;AACA;;;AACAlB,OAAO,CAAC4B,SAAR,GAAoB,SAASC,OAAT,CAAkBX,IAAlB,EAAwB;AAC1C,SAAOA,IAAI,GAAG,CAAP,IAAYA,IAAI,GAAG,IAA1B;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AACAlB,OAAO,CAACmB,WAAR,GAAsB,SAASW,SAAT,CAAoBZ,IAApB,EAA0B;AAC9C,MAAIlB,OAAO,CAAC4B,SAAR,CAAkBV,IAAlB,CAAJ,EAA6B;AAC3B,WAAO,IAAP;AACD;;AAED,MAAIpB,KAAK,CAACoB,IAAD,CAAT,EAAiB;AACf,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD,CAVD;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASa,QAAT,CAAmBC,SAAnB,EAA8B;AAC5BhC,EAAAA,OAAO,CAACe,MAAR,CAAeiB,SAAf,EAD4B,CACF;AAC3B;;AACDhC,OAAO,CAAC+B,QAAR,GAAmBA,QAAnB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA/B,OAAO,CAACiC,MAAR,GAAiB,SAASA,MAAT,CAAiBD,SAAjB,EAA4B;AAC3CD,EAAAA,QAAQ,CAACC,SAAD,CAAR;AAEA,SAAOA,SAAS,CAACpB,KAAV,CAAgB,CAAhB,EAAmB,CAAnB,CAAP;AACD,CAJD","sourcesContent":["/* eslint-disable guard-for-in */\r\n/**\r\n * Multihash implementation in JavaScript.\r\n *\r\n * @module multihash\r\n */\r\n'use strict'\r\n\r\nconst { Buffer } = require('buffer')\r\nconst multibase = require('multibase')\r\nconst varint = require('varint')\r\nconst { names } = require('./constants')\r\n\r\nconst codes = {}\r\n\r\nfor (const key in names) {\r\n  codes[names[key]] = key\r\n}\r\nexports.names = names\r\nexports.codes = Object.freeze(codes)\r\n\r\n/**\r\n * Convert the given multihash to a hex encoded string.\r\n *\r\n * @param {Buffer} hash\r\n * @returns {string}\r\n */\r\nexports.toHexString = function toHexString (hash) {\r\n  if (!Buffer.isBuffer(hash)) {\r\n    throw new Error('must be passed a buffer')\r\n  }\r\n\r\n  return hash.toString('hex')\r\n}\r\n\r\n/**\r\n * Convert the given hex encoded string to a multihash.\r\n *\r\n * @param {string} hash\r\n * @returns {Buffer}\r\n */\r\nexports.fromHexString = function fromHexString (hash) {\r\n  return Buffer.from(hash, 'hex')\r\n}\r\n\r\n/**\r\n * Convert the given multihash to a base58 encoded string.\r\n *\r\n * @param {Buffer} hash\r\n * @returns {string}\r\n */\r\nexports.toB58String = function toB58String (hash) {\r\n  if (!Buffer.isBuffer(hash)) {\r\n    throw new Error('must be passed a buffer')\r\n  }\r\n\r\n  return multibase.encode('base58btc', hash).toString().slice(1)\r\n}\r\n\r\n/**\r\n * Convert the given base58 encoded string to a multihash.\r\n *\r\n * @param {string|Buffer} hash\r\n * @returns {Buffer}\r\n */\r\nexports.fromB58String = function fromB58String (hash) {\r\n  let encoded = hash\r\n  if (Buffer.isBuffer(hash)) {\r\n    encoded = hash.toString()\r\n  }\r\n\r\n  return multibase.decode('z' + encoded)\r\n}\r\n\r\n/**\r\n * Decode a hash from the given multihash.\r\n *\r\n * @param {Buffer} buf\r\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\r\n */\r\nexports.decode = function decode (buf) {\r\n  if (!(Buffer.isBuffer(buf))) {\r\n    throw new Error('multihash must be a Buffer')\r\n  }\r\n\r\n  if (buf.length < 2) {\r\n    throw new Error('multihash too short. must be > 2 bytes.')\r\n  }\r\n\r\n  const code = varint.decode(buf)\r\n  if (!exports.isValidCode(code)) {\r\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\r\n  }\r\n  buf = buf.slice(varint.decode.bytes)\r\n\r\n  const len = varint.decode(buf)\r\n  if (len < 0) {\r\n    throw new Error(`multihash invalid length: ${len}`)\r\n  }\r\n  buf = buf.slice(varint.decode.bytes)\r\n\r\n  if (buf.length !== len) {\r\n    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)\r\n  }\r\n\r\n  return {\r\n    code,\r\n    name: codes[code],\r\n    length: len,\r\n    digest: buf\r\n  }\r\n}\r\n\r\n/**\r\n *  Encode a hash digest along with the specified function code.\r\n *\r\n * > **Note:** the length is derived from the length of the digest itself.\r\n *\r\n * @param {Buffer} digest\r\n * @param {string|number} code\r\n * @param {number} [length]\r\n * @returns {Buffer}\r\n */\r\nexports.encode = function encode (digest, code, length) {\r\n  if (!digest || code === undefined) {\r\n    throw new Error('multihash encode requires at least two args: digest, code')\r\n  }\r\n\r\n  // ensure it's a hashfunction code.\r\n  const hashfn = exports.coerceCode(code)\r\n\r\n  if (!(Buffer.isBuffer(digest))) {\r\n    throw new Error('digest should be a Buffer')\r\n  }\r\n\r\n  if (length == null) {\r\n    length = digest.length\r\n  }\r\n\r\n  if (length && digest.length !== length) {\r\n    throw new Error('digest length should be equal to specified length.')\r\n  }\r\n\r\n  return Buffer.concat([\r\n    Buffer.from(varint.encode(hashfn)),\r\n    Buffer.from(varint.encode(length)),\r\n    digest\r\n  ])\r\n}\r\n\r\n/**\r\n * Converts a hash function name into the matching code.\r\n * If passed a number it will return the number if it's a valid code.\r\n * @param {string|number} name\r\n * @returns {number}\r\n */\r\nexports.coerceCode = function coerceCode (name) {\r\n  let code = name\r\n\r\n  if (typeof name === 'string') {\r\n    if (names[name] === undefined) {\r\n      throw new Error(`Unrecognized hash function named: ${name}`)\r\n    }\r\n    code = names[name]\r\n  }\r\n\r\n  if (typeof code !== 'number') {\r\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\r\n  }\r\n\r\n  if (codes[code] === undefined && !exports.isAppCode(code)) {\r\n    throw new Error(`Unrecognized function code: ${code}`)\r\n  }\r\n\r\n  return code\r\n}\r\n\r\n/**\r\n * Checks wether a code is part of the app range\r\n *\r\n * @param {number} code\r\n * @returns {boolean}\r\n */\r\nexports.isAppCode = function appCode (code) {\r\n  return code > 0 && code < 0x10\r\n}\r\n\r\n/**\r\n * Checks whether a multihash code is valid.\r\n *\r\n * @param {number} code\r\n * @returns {boolean}\r\n */\r\nexports.isValidCode = function validCode (code) {\r\n  if (exports.isAppCode(code)) {\r\n    return true\r\n  }\r\n\r\n  if (codes[code]) {\r\n    return true\r\n  }\r\n\r\n  return false\r\n}\r\n\r\n/**\r\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\r\n *\r\n * @param {Buffer} multihash\r\n * @returns {undefined}\r\n * @throws {Error}\r\n */\r\nfunction validate (multihash) {\r\n  exports.decode(multihash) // throws if bad.\r\n}\r\nexports.validate = validate\r\n\r\n/**\r\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\r\n *\r\n * @param {Buffer} multihash\r\n * @returns {undefined}\r\n * @throws {Error}\r\n */\r\nexports.prefix = function prefix (multihash) {\r\n  validate(multihash)\r\n\r\n  return multihash.slice(0, 2)\r\n}\r\n"]},"metadata":{},"sourceType":"script"}