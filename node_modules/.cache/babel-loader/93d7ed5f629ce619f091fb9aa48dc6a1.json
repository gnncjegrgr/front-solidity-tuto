{"ast":null,"code":"/* eslint-disable class-methods-use-this */\n\n/*\r\n    Copyright 2020 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\nconst lodash = require('lodash');\n\nconst fs = require('fs');\n\nconst IPFSAPI = require('ipfs-http-client-lite');\n\nconst multihash = require('multihashes');\n/**\r\n * Representing a class for uploading and loading files to IPFS.\r\n * @hideconstructor\r\n * @class\r\n */\n\n\nclass IPFS {\n  /**\r\n   * Create an IPFS instance.\r\n   * @param {string} [host] The IPFS Node url to connect with.\r\n   * @param {number} [port] The port number to use.\r\n   * @param {boolean} [ssl] With or without SSL. If true, the https protocol is used. Otherwise, the http protocol is used.\r\n   */\n  constructor(host, port, ssl) {\n    if (host !== undefined && port !== undefined && ssl !== undefined) {\n      this.setIPFSNode(host, port, ssl);\n    }\n  }\n  /**\r\n   * Initializes a connection with an IPFS Node.\r\n   * When an IPFS Node information is set through this function, you can upload files to IPFS or load files from IPFS.\r\n   *\r\n   * @example\r\n   * caver.ipfs.setIPFSNode('localhost', 5001, false)\r\n   *\r\n   * @param {string} host The IPFS Node url to connect with.\r\n   * @param {number} port The port number to use.\r\n   * @param {boolean} ssl With or without SSL. If true, the https protocol is used. Otherwise, the http protocol is used.\r\n   * @return {void}\r\n   */\n\n\n  setIPFSNode(host, port, ssl) {\n    const protocol = ssl ? 'https' : 'http';\n    this.ipfs = IPFSAPI({\n      apiUrl: `${protocol}://${host}:${port}`\n    });\n  }\n  /**\r\n   * Adds a file to IPFS. The {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} of the uploaded file is returned.\r\n   * If the path of a file is passed, the contents of the file are loaded from the path and uploaded to IPFS. If a buffer is passed, it is uploaded to IPFS directly.\r\n   *\r\n   * If the `data` parameter is a `Buffer` or `ArrayBuffer`, upload to IPFS directly without using `fs`.\r\n   * If the `data` parameter is a string, use `fs` to read the file.\r\n   * Since `fs` is a module that can only be used on the server side, if it is client-side code,\r\n   * it must read the file in advance and pass the file contents in the format of `ArrayBuffer`.\r\n   *\r\n   * If you get a \"Error: Can't resolve 'fs'\" error when building your client code, add the following to your \"webpack.config.json\" file.\r\n   * ```\r\n   * module.exports = {\r\n   *     ...\r\n   *     node: {\r\n   *         fs: 'empty',\r\n   *     },\r\n   *     ...\r\n   * }\r\n   * ```\r\n   *\r\n   * If you use Next.js web framework(https://nextjs.org/), add the following to your \"next.config.json\" file.\r\n   * ```\r\n   * module.exports = {\r\n   *     ...\r\n   *     webpack: (config, { isServer }) => {\r\n   *         // Fixes npm packages that depend on `fs` module\r\n   *         if (!isServer) {\r\n   *             config.node = {\r\n   *                 fs: 'empty'\r\n   *             }\r\n   *         }\r\n   *         return config\r\n   *     },\r\n   *     ...\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * const cid = await caver.ipfs.add('./test.txt')\r\n   * const cid = await caver.ipfs.add(Buffer.from('test data'))\r\n   *\r\n   * @param {string|Buffer|ArrayBuffer} data The file path string or file contents.\r\n   * @return {Promise<string>}\r\n   */\n\n\n  async add(data) {\n    if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`); // Read file\n\n    if (lodash.isString(data)) {\n      if (typeof window !== 'undefined') throw new Error(`Cannot use fs module: Please pass the file contents as a parameter of type Buffer or ArrayBuffer.`);\n      data = fs.readFileSync(data);\n    }\n\n    if (!lodash.isBuffer(data) && !lodash.isArrayBuffer(data)) throw new Error(`Invalid data: ${data}`);\n    const ret = await this.ipfs.add(Buffer.from(data));\n    return ret[0].hash;\n  }\n  /**\r\n   * Returns a file addressed by a valid IPFS path.\r\n   *\r\n   * @example\r\n   * const fileContents = await caver.ipfs.get('Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC')\r\n   *\r\n   * @param {string} hash An {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} of the file to download.\r\n   * @return {Promise<Buffer>}\r\n   */\n\n\n  async get(hash) {\n    if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`);\n    const ret = await this.ipfs.cat(hash);\n    return ret;\n  }\n  /**\r\n   * Converts a {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} to a {@link https://multiformats.io/multihash/|Multihash}.\r\n   *\r\n   * @example\r\n   * // This will return '0x1220dc1dbe0bcf1e5f6cce80bd3d7e7d873801c5a1732add889c0f25391d53470dc3'\r\n   * const multihash = caver.ipfs.toHex('Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC')\r\n   *\r\n   * @param {string} hash A {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} to convert.\r\n   * @return {string}\r\n   */\n\n\n  toHex(hash) {\n    const buf = multihash.fromB58String(hash);\n    return `0x${multihash.toHexString(buf)}`;\n  }\n  /**\r\n   * Converts to {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} from a {@link https://multiformats.io/multihash/|Multihash}.\r\n   *\r\n   * @example\r\n   * // This will return 'Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC'\r\n   * const multihash = caver.ipfs.fromHex('0x1220dc1dbe0bcf1e5f6cce80bd3d7e7d873801c5a1732add889c0f25391d53470dc3')\r\n   *\r\n   * @param {string} hash A {@link https://multiformats.io/multihash/|Multihash} to convert.\r\n   * @return {string}\r\n   */\n\n\n  fromHex(contentHash) {\n    const hex = contentHash.substring(2);\n    const buf = multihash.fromHexString(hex);\n    return multihash.toB58String(buf);\n  }\n\n}\n\nmodule.exports = IPFS;","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/caver-js/packages/caver-ipfs/src/index.js"],"names":["lodash","require","fs","IPFSAPI","multihash","IPFS","constructor","host","port","ssl","undefined","setIPFSNode","protocol","ipfs","apiUrl","add","data","Error","isString","window","readFileSync","isBuffer","isArrayBuffer","ret","Buffer","from","hash","get","cat","toHex","buf","fromB58String","toHexString","fromHex","contentHash","hex","substring","fromHexString","toB58String","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable class-methods-use-this */\r\n/*\r\n    Copyright 2020 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst lodash = require('lodash')\r\nconst fs = require('fs')\r\nconst IPFSAPI = require('ipfs-http-client-lite')\r\nconst multihash = require('multihashes')\r\n\r\n/**\r\n * Representing a class for uploading and loading files to IPFS.\r\n * @hideconstructor\r\n * @class\r\n */\r\nclass IPFS {\r\n    /**\r\n     * Create an IPFS instance.\r\n     * @param {string} [host] The IPFS Node url to connect with.\r\n     * @param {number} [port] The port number to use.\r\n     * @param {boolean} [ssl] With or without SSL. If true, the https protocol is used. Otherwise, the http protocol is used.\r\n     */\r\n    constructor(host, port, ssl) {\r\n        if (host !== undefined && port !== undefined && ssl !== undefined) {\r\n            this.setIPFSNode(host, port, ssl)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes a connection with an IPFS Node.\r\n     * When an IPFS Node information is set through this function, you can upload files to IPFS or load files from IPFS.\r\n     *\r\n     * @example\r\n     * caver.ipfs.setIPFSNode('localhost', 5001, false)\r\n     *\r\n     * @param {string} host The IPFS Node url to connect with.\r\n     * @param {number} port The port number to use.\r\n     * @param {boolean} ssl With or without SSL. If true, the https protocol is used. Otherwise, the http protocol is used.\r\n     * @return {void}\r\n     */\r\n    setIPFSNode(host, port, ssl) {\r\n        const protocol = ssl ? 'https' : 'http'\r\n        this.ipfs = IPFSAPI({ apiUrl: `${protocol}://${host}:${port}` })\r\n    }\r\n\r\n    /**\r\n     * Adds a file to IPFS. The {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} of the uploaded file is returned.\r\n     * If the path of a file is passed, the contents of the file are loaded from the path and uploaded to IPFS. If a buffer is passed, it is uploaded to IPFS directly.\r\n     *\r\n     * If the `data` parameter is a `Buffer` or `ArrayBuffer`, upload to IPFS directly without using `fs`.\r\n     * If the `data` parameter is a string, use `fs` to read the file.\r\n     * Since `fs` is a module that can only be used on the server side, if it is client-side code,\r\n     * it must read the file in advance and pass the file contents in the format of `ArrayBuffer`.\r\n     *\r\n     * If you get a \"Error: Can't resolve 'fs'\" error when building your client code, add the following to your \"webpack.config.json\" file.\r\n     * ```\r\n     * module.exports = {\r\n     *     ...\r\n     *     node: {\r\n     *         fs: 'empty',\r\n     *     },\r\n     *     ...\r\n     * }\r\n     * ```\r\n     *\r\n     * If you use Next.js web framework(https://nextjs.org/), add the following to your \"next.config.json\" file.\r\n     * ```\r\n     * module.exports = {\r\n     *     ...\r\n     *     webpack: (config, { isServer }) => {\r\n     *         // Fixes npm packages that depend on `fs` module\r\n     *         if (!isServer) {\r\n     *             config.node = {\r\n     *                 fs: 'empty'\r\n     *             }\r\n     *         }\r\n     *         return config\r\n     *     },\r\n     *     ...\r\n     * }\r\n     * ```\r\n     *\r\n     * @example\r\n     * const cid = await caver.ipfs.add('./test.txt')\r\n     * const cid = await caver.ipfs.add(Buffer.from('test data'))\r\n     *\r\n     * @param {string|Buffer|ArrayBuffer} data The file path string or file contents.\r\n     * @return {Promise<string>}\r\n     */\r\n    async add(data) {\r\n        if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`)\r\n\r\n        // Read file\r\n        if (lodash.isString(data)) {\r\n            if (typeof window !== 'undefined')\r\n                throw new Error(`Cannot use fs module: Please pass the file contents as a parameter of type Buffer or ArrayBuffer.`)\r\n            data = fs.readFileSync(data)\r\n        }\r\n        if (!lodash.isBuffer(data) && !lodash.isArrayBuffer(data)) throw new Error(`Invalid data: ${data}`)\r\n\r\n        const ret = await this.ipfs.add(Buffer.from(data))\r\n        return ret[0].hash\r\n    }\r\n\r\n    /**\r\n     * Returns a file addressed by a valid IPFS path.\r\n     *\r\n     * @example\r\n     * const fileContents = await caver.ipfs.get('Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC')\r\n     *\r\n     * @param {string} hash An {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} of the file to download.\r\n     * @return {Promise<Buffer>}\r\n     */\r\n    async get(hash) {\r\n        if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`)\r\n        const ret = await this.ipfs.cat(hash)\r\n        return ret\r\n    }\r\n\r\n    /**\r\n     * Converts a {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} to a {@link https://multiformats.io/multihash/|Multihash}.\r\n     *\r\n     * @example\r\n     * // This will return '0x1220dc1dbe0bcf1e5f6cce80bd3d7e7d873801c5a1732add889c0f25391d53470dc3'\r\n     * const multihash = caver.ipfs.toHex('Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC')\r\n     *\r\n     * @param {string} hash A {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} to convert.\r\n     * @return {string}\r\n     */\r\n    toHex(hash) {\r\n        const buf = multihash.fromB58String(hash)\r\n        return `0x${multihash.toHexString(buf)}`\r\n    }\r\n\r\n    /**\r\n     * Converts to {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} from a {@link https://multiformats.io/multihash/|Multihash}.\r\n     *\r\n     * @example\r\n     * // This will return 'Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC'\r\n     * const multihash = caver.ipfs.fromHex('0x1220dc1dbe0bcf1e5f6cce80bd3d7e7d873801c5a1732add889c0f25391d53470dc3')\r\n     *\r\n     * @param {string} hash A {@link https://multiformats.io/multihash/|Multihash} to convert.\r\n     * @return {string}\r\n     */\r\n    fromHex(contentHash) {\r\n        const hex = contentHash.substring(2)\r\n        const buf = multihash.fromHexString(hex)\r\n        return multihash.toB58String(buf)\r\n    }\r\n}\r\n\r\nmodule.exports = IPFS\r\n"]},"metadata":{},"sourceType":"script"}