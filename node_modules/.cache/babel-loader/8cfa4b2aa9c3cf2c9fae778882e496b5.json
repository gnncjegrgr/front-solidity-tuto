{"ast":null,"code":"/*\r\n    Copyright 2020 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\nconst AccountLib = require('eth-lib/lib/account');\n\nconst Nat = require('eth-lib/lib/nat');\n\nconst elliptic = require('elliptic');\n\nconst secp256k1 = new elliptic.ec('secp256k1');\n\nconst utils = require('../../../caver-utils');\n\nconst SignatureData = require('./signatureData');\n/**\r\n * Representing a PrivateKey class that includes private key string.\r\n * @class\r\n * @hideconstructor\r\n */\n\n\nclass PrivateKey {\n  /**\r\n   * creates a privateKey.\r\n   * @param {string} key - The private key string.\r\n   */\n  constructor(key) {\n    this.privateKey = key;\n  }\n  /**\r\n   * @type {string}\r\n   */\n\n\n  get privateKey() {\n    return this._privateKey;\n  }\n\n  set privateKey(p) {\n    if (!utils.isValidPrivateKey(p)) throw new Error(`Invalid private key: ${p}`);\n    this._privateKey = utils.addHexPrefix(p);\n  }\n  /**\r\n   * Signs with transactionHash with key and returns signature.\r\n   *\r\n   * @example\r\n   * const signature = privateKey.sign('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550', '0x2810')\r\n   *\r\n   * @param {string} transactionHash The hash of transaction.\r\n   * @param {string|number} chainId The chainId or the network.\r\n   * @return {SignatureData} A {@link SignatureData}.\r\n   */\n\n\n  sign(transactionHash, chainId) {\n    chainId = utils.toHex(chainId);\n    const signature = AccountLib.makeSigner(Nat.toNumber(chainId) * 2 + 35)(transactionHash, this.privateKey);\n    const [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)));\n    return new SignatureData([v, r, s]);\n  }\n  /**\r\n   * Signs with hashed data and returns `signature`.\r\n   *\r\n   * @example\r\n   * const signature = privateKey.signMessage('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550')\r\n   *\r\n   * @param {string} messageHash The hash of data to sign.\r\n   * @return {SignatureData} A {@link SignatureData}.\r\n   */\n\n\n  signMessage(messageHash) {\n    const signature = AccountLib.sign(messageHash, this.privateKey);\n    const [v, r, s] = AccountLib.decodeSignature(signature);\n    return new SignatureData([v, r, s]);\n  }\n  /**\r\n   * Returns public key string.\r\n   *\r\n   * @example\r\n   * const publicKey = privateKey.getPublicKey()\r\n   *\r\n   * @param {boolean} [compressed] Whether in compressed format or not.\r\n   * @return {string} A public key string which is derived from private key string.\r\n   */\n\n\n  getPublicKey() {\n    let compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const strippedPrivateKey = utils.stripHexPrefix(this.privateKey);\n    const ecKey = secp256k1.keyFromPrivate(Buffer.from(strippedPrivateKey, 'hex'));\n    if (!compressed) return `0x${ecKey.getPublic(false, 'hex').slice(2)}`;\n    return `0x${ecKey.getPublic(true, 'hex')}`;\n  }\n  /**\r\n   * Returns derived address from private key string.\r\n   *\r\n   * @example\r\n   * const address = privateKey.getDerivedAddress()\r\n   *\r\n   * @return {string} A address which is derived from private key string.\r\n   */\n\n\n  getDerivedAddress() {\n    return AccountLib.fromPrivate(this.privateKey).address.toLowerCase();\n  }\n\n}\n\nmodule.exports = PrivateKey;","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/caver-js/packages/caver-wallet/src/keyring/privateKey.js"],"names":["AccountLib","require","Nat","elliptic","secp256k1","ec","utils","SignatureData","PrivateKey","constructor","key","privateKey","_privateKey","p","isValidPrivateKey","Error","addHexPrefix","sign","transactionHash","chainId","toHex","signature","makeSigner","toNumber","v","r","s","decodeSignature","map","sig","makeEven","trimLeadingZero","signMessage","messageHash","getPublicKey","compressed","strippedPrivateKey","stripHexPrefix","ecKey","keyFromPrivate","Buffer","from","getPublic","slice","getDerivedAddress","fromPrivate","address","toLowerCase","module","exports"],"mappings":"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","sourcesContent":["/*\r\n    Copyright 2020 The caver-js Authors\r\n    This file is part of the caver-js library.\r\n\r\n    The caver-js library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    The caver-js library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst AccountLib = require('eth-lib/lib/account')\r\nconst Nat = require('eth-lib/lib/nat')\r\n\r\nconst elliptic = require('elliptic')\r\n\r\nconst secp256k1 = new elliptic.ec('secp256k1')\r\n\r\nconst utils = require('../../../caver-utils')\r\nconst SignatureData = require('./signatureData')\r\n\r\n/**\r\n * Representing a PrivateKey class that includes private key string.\r\n * @class\r\n * @hideconstructor\r\n */\r\nclass PrivateKey {\r\n    /**\r\n     * creates a privateKey.\r\n     * @param {string} key - The private key string.\r\n     */\r\n    constructor(key) {\r\n        this.privateKey = key\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get privateKey() {\r\n        return this._privateKey\r\n    }\r\n\r\n    set privateKey(p) {\r\n        if (!utils.isValidPrivateKey(p)) throw new Error(`Invalid private key: ${p}`)\r\n        this._privateKey = utils.addHexPrefix(p)\r\n    }\r\n\r\n    /**\r\n     * Signs with transactionHash with key and returns signature.\r\n     *\r\n     * @example\r\n     * const signature = privateKey.sign('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550', '0x2810')\r\n     *\r\n     * @param {string} transactionHash The hash of transaction.\r\n     * @param {string|number} chainId The chainId or the network.\r\n     * @return {SignatureData} A {@link SignatureData}.\r\n     */\r\n    sign(transactionHash, chainId) {\r\n        chainId = utils.toHex(chainId)\r\n        const signature = AccountLib.makeSigner(Nat.toNumber(chainId) * 2 + 35)(transactionHash, this.privateKey)\r\n        const [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)))\r\n        return new SignatureData([v, r, s])\r\n    }\r\n\r\n    /**\r\n     * Signs with hashed data and returns `signature`.\r\n     *\r\n     * @example\r\n     * const signature = privateKey.signMessage('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550')\r\n     *\r\n     * @param {string} messageHash The hash of data to sign.\r\n     * @return {SignatureData} A {@link SignatureData}.\r\n     */\r\n    signMessage(messageHash) {\r\n        const signature = AccountLib.sign(messageHash, this.privateKey)\r\n        const [v, r, s] = AccountLib.decodeSignature(signature)\r\n        return new SignatureData([v, r, s])\r\n    }\r\n\r\n    /**\r\n     * Returns public key string.\r\n     *\r\n     * @example\r\n     * const publicKey = privateKey.getPublicKey()\r\n     *\r\n     * @param {boolean} [compressed] Whether in compressed format or not.\r\n     * @return {string} A public key string which is derived from private key string.\r\n     */\r\n    getPublicKey(compressed = false) {\r\n        const strippedPrivateKey = utils.stripHexPrefix(this.privateKey)\r\n\r\n        const ecKey = secp256k1.keyFromPrivate(Buffer.from(strippedPrivateKey, 'hex'))\r\n\r\n        if (!compressed) return `0x${ecKey.getPublic(false, 'hex').slice(2)}`\r\n        return `0x${ecKey.getPublic(true, 'hex')}`\r\n    }\r\n\r\n    /**\r\n     * Returns derived address from private key string.\r\n     *\r\n     * @example\r\n     * const address = privateKey.getDerivedAddress()\r\n     *\r\n     * @return {string} A address which is derived from private key string.\r\n     */\r\n    getDerivedAddress() {\r\n        return AccountLib.fromPrivate(this.privateKey).address.toLowerCase()\r\n    }\r\n}\r\n\r\nmodule.exports = PrivateKey\r\n"]},"metadata":{},"sourceType":"script"}