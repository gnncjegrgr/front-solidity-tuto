{"ast":null,"code":"'use strict';\n\nconst cbor = require('borc');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst multicodec = require('multicodec');\n\nconst multihashing = require('multihashing-async');\n\nconst CID = require('cids');\n\nconst isCircular = require('is-circular'); // https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\n\n\nconst CID_CBOR_TAG = 42;\n\nfunction tagCID(cid) {\n  if (typeof cid === 'string') {\n    cid = new CID(cid).buffer;\n  } else if (CID.isCID(cid)) {\n    cid = cid.buffer;\n  }\n\n  return new cbor.Tagged(CID_CBOR_TAG, Buffer.concat([Buffer.from('00', 'hex'), // thanks jdag\n  cid]));\n}\n\nfunction replaceCIDbyTAG(dagNode) {\n  let circular;\n\n  try {\n    circular = isCircular(dagNode);\n  } catch (e) {\n    circular = false;\n  }\n\n  if (circular) {\n    throw new Error('The object passed has circular references');\n  }\n\n  function transform(obj) {\n    if (!obj || obj instanceof Uint8Array || typeof obj === 'string') {\n      return obj;\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(transform);\n    }\n\n    if (CID.isCID(obj)) {\n      return tagCID(obj);\n    }\n\n    const keys = Object.keys(obj);\n\n    if (keys.length > 0) {\n      // Recursive transform\n      const out = {};\n      keys.forEach(key => {\n        if (typeof obj[key] === 'object') {\n          out[key] = transform(obj[key]);\n        } else {\n          out[key] = obj[key];\n        }\n      });\n      return out;\n    } else {\n      return obj;\n    }\n  }\n\n  return transform(dagNode);\n}\n\nexports = module.exports;\nexports.codec = multicodec.DAG_CBOR;\nexports.defaultHashAlg = multicodec.SHA2_256;\nconst defaultTags = {\n  [CID_CBOR_TAG]: val => {\n    // remove that 0\n    val = val.slice(1);\n    return new CID(val);\n  }\n};\nconst defaultSize = 64 * 1024; // current decoder heap size, 64 Kb\n\nlet currentSize = defaultSize;\nconst defaultMaxSize = 64 * 1024 * 1024; // max heap size when auto-growing, 64 Mb\n\nlet maxSize = defaultMaxSize;\nlet decoder = null;\n/**\r\n * Configure the underlying CBOR decoder.\r\n *\r\n * @param {Object} [options] - The options the decoder takes. The decoder will reset to the defaul values if no options are given.\r\n * @param {number} [options.size=65536] - The current heap size used in CBOR parsing, this may grow automatically as larger blocks are encountered up to `maxSize`\r\n * @param {number} [options.maxSize=67108864] - The maximum size the CBOR parsing heap is allowed to grow to before `dagCBOR.util.deserialize()` returns an error\r\n * @param {Object} [options.tags] - An object whose keys are CBOR tag numbers and values are transform functions that accept a `value` and return a decoded representation of that `value`\r\n */\n\nexports.configureDecoder = options => {\n  let tags = defaultTags;\n\n  if (options) {\n    if (typeof options.size === 'number') {\n      currentSize = options.size;\n    }\n\n    if (typeof options.maxSize === 'number') {\n      maxSize = options.maxSize;\n    }\n\n    if (options.tags) {\n      tags = Object.assign({}, defaultTags, options && options.tags);\n    }\n  } else {\n    // no options, reset to defaults\n    currentSize = defaultSize;\n    maxSize = defaultMaxSize;\n  }\n\n  const decoderOptions = {\n    tags,\n    size: currentSize\n  };\n  decoder = new cbor.Decoder(decoderOptions); // borc edits opts.size in-place so we can capture _actual_ size\n\n  currentSize = decoderOptions.size;\n};\n\nexports.configureDecoder(); // Setup default cbor.Decoder\n\n/**\r\n * Serialize internal representation into a binary CBOR block.\r\n *\r\n * @param {Object} node - Internal representation of a CBOR block\r\n * @returns {Buffer} - The encoded binary representation\r\n */\n\nexports.serialize = node => {\n  const nodeTagged = replaceCIDbyTAG(node);\n  const serialized = cbor.encode(nodeTagged);\n  return serialized;\n};\n/**\r\n * Deserialize CBOR block into the internal representation.\r\n *\r\n * @param {Buffer} data - Binary representation of a CBOR block\r\n * @returns {Object} - An object that conforms to the IPLD Data Model\r\n */\n\n\nexports.deserialize = data => {\n  if (data.length > currentSize && data.length <= maxSize) {\n    exports.configureDecoder({\n      size: data.length\n    });\n  }\n\n  if (data.length > currentSize) {\n    throw new Error('Data is too large to deserialize with current decoder');\n  }\n\n  const deserialized = decoder.decodeFirst(data);\n  return deserialized;\n};\n/**\r\n * Calculate the CID of the binary blob.\r\n *\r\n * @param {Object} binaryBlob - Encoded IPLD Node\r\n * @param {Object} [userOptions] - Options to create the CID\r\n * @param {number} [userOptions.cidVersion=1] - CID version number\r\n * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format\r\n * @returns {Promise.<CID>}\r\n */\n\n\nexports.cid = async (binaryBlob, userOptions) => {\n  const defaultOptions = {\n    cidVersion: 1,\n    hashAlg: exports.defaultHashAlg\n  };\n  const options = Object.assign(defaultOptions, userOptions);\n  const multihash = await multihashing(binaryBlob, options.hashAlg);\n  const codecName = multicodec.print[exports.codec];\n  const cid = new CID(options.cidVersion, codecName, multihash);\n  return cid;\n};","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/ipld-dag-cbor/src/util.js"],"names":["cbor","require","Buffer","multicodec","multihashing","CID","isCircular","CID_CBOR_TAG","tagCID","cid","buffer","isCID","Tagged","concat","from","replaceCIDbyTAG","dagNode","circular","e","Error","transform","obj","Uint8Array","Array","isArray","map","keys","Object","length","out","forEach","key","exports","module","codec","DAG_CBOR","defaultHashAlg","SHA2_256","defaultTags","val","slice","defaultSize","currentSize","defaultMaxSize","maxSize","decoder","configureDecoder","options","tags","size","assign","decoderOptions","Decoder","serialize","node","nodeTagged","serialized","encode","deserialize","data","deserialized","decodeFirst","binaryBlob","userOptions","defaultOptions","cidVersion","hashAlg","multihash","codecName","print"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst cbor = require('borc')\r\nconst { Buffer } = require('buffer')\r\nconst multicodec = require('multicodec')\r\nconst multihashing = require('multihashing-async')\r\nconst CID = require('cids')\r\nconst isCircular = require('is-circular')\r\n\r\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\r\nconst CID_CBOR_TAG = 42\r\n\r\nfunction tagCID (cid) {\r\n  if (typeof cid === 'string') {\r\n    cid = new CID(cid).buffer\r\n  } else if (CID.isCID(cid)) {\r\n    cid = cid.buffer\r\n  }\r\n\r\n  return new cbor.Tagged(CID_CBOR_TAG, Buffer.concat([\r\n    Buffer.from('00', 'hex'), // thanks jdag\r\n    cid\r\n  ]))\r\n}\r\n\r\nfunction replaceCIDbyTAG (dagNode) {\r\n  let circular\r\n  try {\r\n    circular = isCircular(dagNode)\r\n  } catch (e) {\r\n    circular = false\r\n  }\r\n  if (circular) {\r\n    throw new Error('The object passed has circular references')\r\n  }\r\n\r\n  function transform (obj) {\r\n    if (!obj || obj instanceof Uint8Array || typeof obj === 'string') {\r\n      return obj\r\n    }\r\n\r\n    if (Array.isArray(obj)) {\r\n      return obj.map(transform)\r\n    }\r\n\r\n    if (CID.isCID(obj)) {\r\n      return tagCID(obj)\r\n    }\r\n\r\n    const keys = Object.keys(obj)\r\n\r\n    if (keys.length > 0) {\r\n      // Recursive transform\r\n      const out = {}\r\n      keys.forEach((key) => {\r\n        if (typeof obj[key] === 'object') {\r\n          out[key] = transform(obj[key])\r\n        } else {\r\n          out[key] = obj[key]\r\n        }\r\n      })\r\n      return out\r\n    } else {\r\n      return obj\r\n    }\r\n  }\r\n\r\n  return transform(dagNode)\r\n}\r\n\r\nexports = module.exports\r\n\r\nexports.codec = multicodec.DAG_CBOR\r\nexports.defaultHashAlg = multicodec.SHA2_256\r\n\r\nconst defaultTags = {\r\n  [CID_CBOR_TAG]: (val) => {\r\n    // remove that 0\r\n    val = val.slice(1)\r\n    return new CID(val)\r\n  }\r\n}\r\nconst defaultSize = 64 * 1024 // current decoder heap size, 64 Kb\r\nlet currentSize = defaultSize\r\nconst defaultMaxSize = 64 * 1024 * 1024 // max heap size when auto-growing, 64 Mb\r\nlet maxSize = defaultMaxSize\r\nlet decoder = null\r\n\r\n/**\r\n * Configure the underlying CBOR decoder.\r\n *\r\n * @param {Object} [options] - The options the decoder takes. The decoder will reset to the defaul values if no options are given.\r\n * @param {number} [options.size=65536] - The current heap size used in CBOR parsing, this may grow automatically as larger blocks are encountered up to `maxSize`\r\n * @param {number} [options.maxSize=67108864] - The maximum size the CBOR parsing heap is allowed to grow to before `dagCBOR.util.deserialize()` returns an error\r\n * @param {Object} [options.tags] - An object whose keys are CBOR tag numbers and values are transform functions that accept a `value` and return a decoded representation of that `value`\r\n */\r\nexports.configureDecoder = (options) => {\r\n  let tags = defaultTags\r\n\r\n  if (options) {\r\n    if (typeof options.size === 'number') {\r\n      currentSize = options.size\r\n    }\r\n    if (typeof options.maxSize === 'number') {\r\n      maxSize = options.maxSize\r\n    }\r\n    if (options.tags) {\r\n      tags = Object.assign({}, defaultTags, options && options.tags)\r\n    }\r\n  } else {\r\n    // no options, reset to defaults\r\n    currentSize = defaultSize\r\n    maxSize = defaultMaxSize\r\n  }\r\n\r\n  const decoderOptions = {\r\n    tags,\r\n    size: currentSize\r\n  }\r\n\r\n  decoder = new cbor.Decoder(decoderOptions)\r\n  // borc edits opts.size in-place so we can capture _actual_ size\r\n  currentSize = decoderOptions.size\r\n}\r\n\r\nexports.configureDecoder() // Setup default cbor.Decoder\r\n\r\n/**\r\n * Serialize internal representation into a binary CBOR block.\r\n *\r\n * @param {Object} node - Internal representation of a CBOR block\r\n * @returns {Buffer} - The encoded binary representation\r\n */\r\nexports.serialize = (node) => {\r\n  const nodeTagged = replaceCIDbyTAG(node)\r\n  const serialized = cbor.encode(nodeTagged)\r\n\r\n  return serialized\r\n}\r\n\r\n/**\r\n * Deserialize CBOR block into the internal representation.\r\n *\r\n * @param {Buffer} data - Binary representation of a CBOR block\r\n * @returns {Object} - An object that conforms to the IPLD Data Model\r\n */\r\nexports.deserialize = (data) => {\r\n  if (data.length > currentSize && data.length <= maxSize) {\r\n    exports.configureDecoder({ size: data.length })\r\n  }\r\n\r\n  if (data.length > currentSize) {\r\n    throw new Error('Data is too large to deserialize with current decoder')\r\n  }\r\n\r\n  const deserialized = decoder.decodeFirst(data)\r\n\r\n  return deserialized\r\n}\r\n\r\n/**\r\n * Calculate the CID of the binary blob.\r\n *\r\n * @param {Object} binaryBlob - Encoded IPLD Node\r\n * @param {Object} [userOptions] - Options to create the CID\r\n * @param {number} [userOptions.cidVersion=1] - CID version number\r\n * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format\r\n * @returns {Promise.<CID>}\r\n */\r\nexports.cid = async (binaryBlob, userOptions) => {\r\n  const defaultOptions = { cidVersion: 1, hashAlg: exports.defaultHashAlg }\r\n  const options = Object.assign(defaultOptions, userOptions)\r\n\r\n  const multihash = await multihashing(binaryBlob, options.hashAlg)\r\n  const codecName = multicodec.print[exports.codec]\r\n  const cid = new CID(options.cidVersion, codecName, multihash)\r\n\r\n  return cid\r\n}\r\n"]},"metadata":{},"sourceType":"script"}