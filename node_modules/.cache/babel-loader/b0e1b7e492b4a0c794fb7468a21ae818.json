{"ast":null,"code":"'use strict';\n\nconst multiaddr = require('multiaddr');\n/*\r\n * Valid combinations\r\n */\n\n\nconst DNS4 = base('dns4');\nconst DNS6 = base('dns6');\nconst DNS = or(base('dns'), base('dnsaddr'), DNS4, DNS6);\nconst IP = or(base('ip4'), base('ip6'));\nconst TCP = or(and(IP, base('tcp')), and(DNS, base('tcp')));\nconst UDP = and(IP, base('udp'));\nconst UTP = and(UDP, base('utp'));\nconst WebSockets = or(and(TCP, base('ws')), and(DNS, base('ws')));\nconst WebSocketsSecure = or(and(TCP, base('wss')), and(DNS, base('wss')));\nconst HTTP = or(and(TCP, base('http')), and(IP, base('http')), and(DNS, base('http')));\nconst HTTPS = or(and(TCP, base('https')), and(IP, base('https')), and(DNS, base('https')));\nconst WebRTCStar = or(and(WebSockets, base('p2p-webrtc-star'), base('p2p')), and(WebSocketsSecure, base('p2p-webrtc-star'), base('p2p')), and(WebSockets, base('p2p-webrtc-star')), and(WebSocketsSecure, base('p2p-webrtc-star')));\nconst WebSocketStar = or(and(WebSockets, base('p2p-websocket-star'), base('p2p')), and(WebSocketsSecure, base('p2p-websocket-star'), base('p2p')), and(WebSockets, base('p2p-websocket-star')), and(WebSocketsSecure, base('p2p-websocket-star')));\nconst WebRTCDirect = or(and(HTTP, base('p2p-webrtc-direct')), and(HTTPS, base('p2p-webrtc-direct')));\nconst Reliable = or(WebSockets, WebSocketsSecure, HTTP, HTTPS, WebRTCStar, WebRTCDirect, TCP, UTP); // Unlike ws-star, stardust can run over any transport thus removing the requirement for websockets (but don't even think about running a stardust server over webrtc-star ;) )\n\nconst Stardust = or(and(Reliable, base('p2p-stardust'), base('p2p')), and(Reliable, base('p2p-stardust')));\n\nconst _P2P = or(and(Reliable, base('p2p')), WebRTCStar, base('p2p'));\n\nconst _Circuit = or(and(_P2P, base('p2p-circuit'), _P2P), and(_P2P, base('p2p-circuit')), and(base('p2p-circuit'), _P2P), and(Reliable, base('p2p-circuit')), and(base('p2p-circuit'), Reliable), base('p2p-circuit'));\n\nconst CircuitRecursive = () => or(and(_Circuit, CircuitRecursive), _Circuit);\n\nconst Circuit = CircuitRecursive();\nconst P2P = or(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);\nexports.DNS = DNS;\nexports.DNS4 = DNS4;\nexports.DNS6 = DNS6;\nexports.IP = IP;\nexports.TCP = TCP;\nexports.UDP = UDP;\nexports.UTP = UTP;\nexports.HTTP = HTTP;\nexports.HTTPS = HTTPS;\nexports.WebSockets = WebSockets;\nexports.WebSocketsSecure = WebSocketsSecure;\nexports.WebSocketStar = WebSocketStar;\nexports.WebRTCStar = WebRTCStar;\nexports.WebRTCDirect = WebRTCDirect;\nexports.Reliable = Reliable;\nexports.Stardust = Stardust;\nexports.Circuit = Circuit;\nexports.P2P = P2P;\nexports.IPFS = P2P;\n/*\r\n * Validation funcs\r\n */\n\nfunction makeMatchesFunction(partialMatch) {\n  return function matches(a) {\n    if (!multiaddr.isMultiaddr(a)) {\n      try {\n        a = multiaddr(a);\n      } catch (err) {\n        // catch error\n        return false; // also if it's invalid it's propably not matching as well so return false\n      }\n    }\n\n    const out = partialMatch(a.protoNames());\n\n    if (out === null) {\n      return false;\n    }\n\n    return out.length === 0;\n  };\n}\n\nfunction and() {\n  const args = Array.from(arguments);\n\n  function partialMatch(a) {\n    if (a.length < args.length) {\n      return null;\n    }\n\n    args.some(arg => {\n      a = typeof arg === 'function' ? arg().partialMatch(a) : arg.partialMatch(a);\n\n      if (a === null) {\n        return true;\n      }\n    });\n    return a;\n  }\n\n  return {\n    toString: function () {\n      return '{ ' + args.join(' ') + ' }';\n    },\n    input: args,\n    matches: makeMatchesFunction(partialMatch),\n    partialMatch: partialMatch\n  };\n}\n\nfunction or() {\n  const args = Array.from(arguments);\n\n  function partialMatch(a) {\n    let out = null;\n    args.some(arg => {\n      const res = typeof arg === 'function' ? arg().partialMatch(a) : arg.partialMatch(a);\n\n      if (res) {\n        out = res;\n        return true;\n      }\n    });\n    return out;\n  }\n\n  const result = {\n    toString: function () {\n      return '{ ' + args.join(' ') + ' }';\n    },\n    input: args,\n    matches: makeMatchesFunction(partialMatch),\n    partialMatch: partialMatch\n  };\n  return result;\n}\n\nfunction base(n) {\n  const name = n;\n\n  function matches(a) {\n    if (typeof a === 'string') {\n      try {\n        a = multiaddr(a);\n      } catch (err) {\n        // catch error\n        return false; // also if it's invalid it's propably not matching as well so return false\n      }\n    }\n\n    const pnames = a.protoNames();\n\n    if (pnames.length === 1 && pnames[0] === name) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function partialMatch(protos) {\n    if (protos.length === 0) {\n      return null;\n    }\n\n    if (protos[0] === name) {\n      return protos.slice(1);\n    }\n\n    return null;\n  }\n\n  return {\n    toString: function () {\n      return name;\n    },\n    matches: matches,\n    partialMatch: partialMatch\n  };\n}","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/mafmt/src/index.js"],"names":["multiaddr","require","DNS4","base","DNS6","DNS","or","IP","TCP","and","UDP","UTP","WebSockets","WebSocketsSecure","HTTP","HTTPS","WebRTCStar","WebSocketStar","WebRTCDirect","Reliable","Stardust","_P2P","_Circuit","CircuitRecursive","Circuit","P2P","exports","IPFS","makeMatchesFunction","partialMatch","matches","a","isMultiaddr","err","out","protoNames","length","args","Array","from","arguments","some","arg","toString","join","input","res","result","n","name","pnames","protos","slice"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst multiaddr = require('multiaddr')\r\n\r\n/*\r\n * Valid combinations\r\n */\r\nconst DNS4 = base('dns4')\r\nconst DNS6 = base('dns6')\r\nconst DNS = or(\r\n  base('dns'),\r\n  base('dnsaddr'),\r\n  DNS4,\r\n  DNS6\r\n)\r\n\r\nconst IP = or(base('ip4'), base('ip6'))\r\nconst TCP = or(\r\n  and(IP, base('tcp')),\r\n  and(DNS, base('tcp'))\r\n)\r\nconst UDP = and(IP, base('udp'))\r\nconst UTP = and(UDP, base('utp'))\r\n\r\nconst WebSockets = or(\r\n  and(TCP, base('ws')),\r\n  and(DNS, base('ws'))\r\n)\r\n\r\nconst WebSocketsSecure = or(\r\n  and(TCP, base('wss')),\r\n  and(DNS, base('wss'))\r\n)\r\n\r\nconst HTTP = or(\r\n  and(TCP, base('http')),\r\n  and(IP, base('http')),\r\n  and(DNS, base('http'))\r\n)\r\n\r\nconst HTTPS = or(\r\n  and(TCP, base('https')),\r\n  and(IP, base('https')),\r\n  and(DNS, base('https'))\r\n)\r\n\r\nconst WebRTCStar = or(\r\n  and(WebSockets, base('p2p-webrtc-star'), base('p2p')),\r\n  and(WebSocketsSecure, base('p2p-webrtc-star'), base('p2p')),\r\n  and(WebSockets, base('p2p-webrtc-star')),\r\n  and(WebSocketsSecure, base('p2p-webrtc-star'))\r\n)\r\n\r\nconst WebSocketStar = or(\r\n  and(WebSockets, base('p2p-websocket-star'), base('p2p')),\r\n  and(WebSocketsSecure, base('p2p-websocket-star'), base('p2p')),\r\n  and(WebSockets, base('p2p-websocket-star')),\r\n  and(WebSocketsSecure, base('p2p-websocket-star'))\r\n)\r\n\r\nconst WebRTCDirect = or(\r\n  and(HTTP, base('p2p-webrtc-direct')),\r\n  and(HTTPS, base('p2p-webrtc-direct'))\r\n)\r\n\r\nconst Reliable = or(\r\n  WebSockets,\r\n  WebSocketsSecure,\r\n  HTTP,\r\n  HTTPS,\r\n  WebRTCStar,\r\n  WebRTCDirect,\r\n  TCP,\r\n  UTP\r\n)\r\n\r\n// Unlike ws-star, stardust can run over any transport thus removing the requirement for websockets (but don't even think about running a stardust server over webrtc-star ;) )\r\nconst Stardust = or(\r\n  and(Reliable, base('p2p-stardust'), base('p2p')),\r\n  and(Reliable, base('p2p-stardust'))\r\n)\r\n\r\nconst _P2P = or(\r\n  and(Reliable, base('p2p')),\r\n  WebRTCStar,\r\n  base('p2p')\r\n)\r\n\r\nconst _Circuit = or(\r\n  and(_P2P, base('p2p-circuit'), _P2P),\r\n  and(_P2P, base('p2p-circuit')),\r\n  and(base('p2p-circuit'), _P2P),\r\n  and(Reliable, base('p2p-circuit')),\r\n  and(base('p2p-circuit'), Reliable),\r\n  base('p2p-circuit')\r\n)\r\n\r\nconst CircuitRecursive = () => or(\r\n  and(_Circuit, CircuitRecursive),\r\n  _Circuit\r\n)\r\n\r\nconst Circuit = CircuitRecursive()\r\n\r\nconst P2P = or(\r\n  and(Circuit, _P2P, Circuit),\r\n  and(_P2P, Circuit),\r\n  and(Circuit, _P2P),\r\n  Circuit,\r\n  _P2P\r\n)\r\n\r\nexports.DNS = DNS\r\nexports.DNS4 = DNS4\r\nexports.DNS6 = DNS6\r\nexports.IP = IP\r\nexports.TCP = TCP\r\nexports.UDP = UDP\r\nexports.UTP = UTP\r\nexports.HTTP = HTTP\r\nexports.HTTPS = HTTPS\r\nexports.WebSockets = WebSockets\r\nexports.WebSocketsSecure = WebSocketsSecure\r\nexports.WebSocketStar = WebSocketStar\r\nexports.WebRTCStar = WebRTCStar\r\nexports.WebRTCDirect = WebRTCDirect\r\nexports.Reliable = Reliable\r\nexports.Stardust = Stardust\r\nexports.Circuit = Circuit\r\nexports.P2P = P2P\r\nexports.IPFS = P2P\r\n\r\n/*\r\n * Validation funcs\r\n */\r\n\r\nfunction makeMatchesFunction (partialMatch) {\r\n  return function matches (a) {\r\n    if (!multiaddr.isMultiaddr(a)) {\r\n      try {\r\n        a = multiaddr(a)\r\n      } catch (err) { // catch error\r\n        return false // also if it's invalid it's propably not matching as well so return false\r\n      }\r\n    }\r\n    const out = partialMatch(a.protoNames())\r\n    if (out === null) {\r\n      return false\r\n    }\r\n    return out.length === 0\r\n  }\r\n}\r\n\r\nfunction and () {\r\n  const args = Array.from(arguments)\r\n  function partialMatch (a) {\r\n    if (a.length < args.length) {\r\n      return null\r\n    }\r\n    args.some((arg) => {\r\n      a = typeof arg === 'function'\r\n        ? arg().partialMatch(a)\r\n        : arg.partialMatch(a)\r\n\r\n      if (a === null) {\r\n        return true\r\n      }\r\n    })\r\n\r\n    return a\r\n  }\r\n\r\n  return {\r\n    toString: function () { return '{ ' + args.join(' ') + ' }' },\r\n    input: args,\r\n    matches: makeMatchesFunction(partialMatch),\r\n    partialMatch: partialMatch\r\n  }\r\n}\r\n\r\nfunction or () {\r\n  const args = Array.from(arguments)\r\n\r\n  function partialMatch (a) {\r\n    let out = null\r\n    args.some((arg) => {\r\n      const res = typeof arg === 'function'\r\n        ? arg().partialMatch(a)\r\n        : arg.partialMatch(a)\r\n      if (res) {\r\n        out = res\r\n        return true\r\n      }\r\n    })\r\n\r\n    return out\r\n  }\r\n\r\n  const result = {\r\n    toString: function () { return '{ ' + args.join(' ') + ' }' },\r\n    input: args,\r\n    matches: makeMatchesFunction(partialMatch),\r\n    partialMatch: partialMatch\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nfunction base (n) {\r\n  const name = n\r\n\r\n  function matches (a) {\r\n    if (typeof a === 'string') {\r\n      try {\r\n        a = multiaddr(a)\r\n      } catch (err) { // catch error\r\n        return false // also if it's invalid it's propably not matching as well so return false\r\n      }\r\n    }\r\n\r\n    const pnames = a.protoNames()\r\n    if (pnames.length === 1 && pnames[0] === name) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  function partialMatch (protos) {\r\n    if (protos.length === 0) {\r\n      return null\r\n    }\r\n\r\n    if (protos[0] === name) {\r\n      return protos.slice(1)\r\n    }\r\n    return null\r\n  }\r\n\r\n  return {\r\n    toString: function () { return name },\r\n    matches: matches,\r\n    partialMatch: partialMatch\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}