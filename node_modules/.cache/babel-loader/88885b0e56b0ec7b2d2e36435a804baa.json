{"ast":null,"code":"'use strict';\n\nconst promisify = require('promisify-es6');\n\nconst IsIpfs = require('is-ipfs');\n\nconst moduleConfig = require('../utils/module-config');\n\nconst cleanCID = require('../utils/clean-cid');\n\nmodule.exports = arg => {\n  const send = moduleConfig(arg);\n  return promisify((args, opts, callback) => {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    try {\n      args = cleanCID(args);\n    } catch (err) {\n      if (!IsIpfs.ipfsPath(args)) {\n        return callback(err);\n      }\n    }\n\n    send({\n      path: 'ls',\n      args: args,\n      qs: opts\n    }, (err, results) => {\n      if (err) {\n        return callback(err);\n      }\n\n      let result = results.Objects;\n\n      if (!result) {\n        return callback(new Error('expected .Objects in results'));\n      }\n\n      result = result[0];\n\n      if (!result) {\n        return callback(new Error('expected one array in results.Objects'));\n      }\n\n      result = result.Links;\n\n      if (!Array.isArray(result)) {\n        return callback(new Error('expected one array in results.Objects[0].Links'));\n      }\n\n      result = result.map(link => ({\n        name: link.Name,\n        path: args + '/' + link.Name,\n        size: link.Size,\n        hash: link.Hash,\n        type: typeOf(link),\n        depth: link.Depth || 1\n      }));\n      callback(null, result);\n    });\n  });\n};\n\nfunction typeOf(link) {\n  switch (link.Type) {\n    case 1:\n    case 5:\n      return 'dir';\n\n    case 2:\n      return 'file';\n\n    default:\n      return 'unknown';\n  }\n}","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/ipfs-http-client/src/files-regular/ls.js"],"names":["promisify","require","IsIpfs","moduleConfig","cleanCID","module","exports","arg","send","args","opts","callback","err","ipfsPath","path","qs","results","result","Objects","Error","Links","Array","isArray","map","link","name","Name","size","Size","hash","Hash","type","typeOf","depth","Depth","Type"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,eAAD,CAAzB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,wBAAD,CAA5B;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,oBAAD,CAAxB;;AAEAI,MAAM,CAACC,OAAP,GAAkBC,GAAD,IAAS;AACxB,QAAMC,IAAI,GAAGL,YAAY,CAACI,GAAD,CAAzB;AAEA,SAAOP,SAAS,CAAC,CAACS,IAAD,EAAOC,IAAP,EAAaC,QAAb,KAA0B;AACzC,QAAI,OAAQD,IAAR,KAAkB,UAAtB,EAAkC;AAChCC,MAAAA,QAAQ,GAAGD,IAAX;AACAA,MAAAA,IAAI,GAAG,EAAP;AACD;;AAED,QAAI;AACFD,MAAAA,IAAI,GAAGL,QAAQ,CAACK,IAAD,CAAf;AACD,KAFD,CAEE,OAAOG,GAAP,EAAY;AACZ,UAAI,CAACV,MAAM,CAACW,QAAP,CAAgBJ,IAAhB,CAAL,EAA4B;AAC1B,eAAOE,QAAQ,CAACC,GAAD,CAAf;AACD;AACF;;AAEDJ,IAAAA,IAAI,CAAC;AACHM,MAAAA,IAAI,EAAE,IADH;AAEHL,MAAAA,IAAI,EAAEA,IAFH;AAGHM,MAAAA,EAAE,EAAEL;AAHD,KAAD,EAID,CAACE,GAAD,EAAMI,OAAN,KAAkB;AACnB,UAAIJ,GAAJ,EAAS;AACP,eAAOD,QAAQ,CAACC,GAAD,CAAf;AACD;;AAED,UAAIK,MAAM,GAAGD,OAAO,CAACE,OAArB;;AACA,UAAI,CAACD,MAAL,EAAa;AACX,eAAON,QAAQ,CAAC,IAAIQ,KAAJ,CAAU,8BAAV,CAAD,CAAf;AACD;;AAEDF,MAAAA,MAAM,GAAGA,MAAM,CAAC,CAAD,CAAf;;AACA,UAAI,CAACA,MAAL,EAAa;AACX,eAAON,QAAQ,CAAC,IAAIQ,KAAJ,CAAU,uCAAV,CAAD,CAAf;AACD;;AAEDF,MAAAA,MAAM,GAAGA,MAAM,CAACG,KAAhB;;AACA,UAAI,CAACC,KAAK,CAACC,OAAN,CAAcL,MAAd,CAAL,EAA4B;AAC1B,eAAON,QAAQ,CAAC,IAAIQ,KAAJ,CAAU,gDAAV,CAAD,CAAf;AACD;;AAEDF,MAAAA,MAAM,GAAGA,MAAM,CAACM,GAAP,CAAYC,IAAD,KAAW;AAC7BC,QAAAA,IAAI,EAAED,IAAI,CAACE,IADkB;AAE7BZ,QAAAA,IAAI,EAAEL,IAAI,GAAG,GAAP,GAAae,IAAI,CAACE,IAFK;AAG7BC,QAAAA,IAAI,EAAEH,IAAI,CAACI,IAHkB;AAI7BC,QAAAA,IAAI,EAAEL,IAAI,CAACM,IAJkB;AAK7BC,QAAAA,IAAI,EAAEC,MAAM,CAACR,IAAD,CALiB;AAM7BS,QAAAA,KAAK,EAAET,IAAI,CAACU,KAAL,IAAc;AANQ,OAAX,CAAX,CAAT;AASAvB,MAAAA,QAAQ,CAAC,IAAD,EAAOM,MAAP,CAAR;AACD,KAlCG,CAAJ;AAmCD,GAjDe,CAAhB;AAkDD,CArDD;;AAuDA,SAASe,MAAT,CAAiBR,IAAjB,EAAuB;AACrB,UAAQA,IAAI,CAACW,IAAb;AACE,SAAK,CAAL;AACA,SAAK,CAAL;AACE,aAAO,KAAP;;AACF,SAAK,CAAL;AACE,aAAO,MAAP;;AACF;AACE,aAAO,SAAP;AAPJ;AASD","sourcesContent":["'use strict'\r\n\r\nconst promisify = require('promisify-es6')\r\nconst IsIpfs = require('is-ipfs')\r\nconst moduleConfig = require('../utils/module-config')\r\nconst cleanCID = require('../utils/clean-cid')\r\n\r\nmodule.exports = (arg) => {\r\n  const send = moduleConfig(arg)\r\n\r\n  return promisify((args, opts, callback) => {\r\n    if (typeof (opts) === 'function') {\r\n      callback = opts\r\n      opts = {}\r\n    }\r\n\r\n    try {\r\n      args = cleanCID(args)\r\n    } catch (err) {\r\n      if (!IsIpfs.ipfsPath(args)) {\r\n        return callback(err)\r\n      }\r\n    }\r\n\r\n    send({\r\n      path: 'ls',\r\n      args: args,\r\n      qs: opts\r\n    }, (err, results) => {\r\n      if (err) {\r\n        return callback(err)\r\n      }\r\n\r\n      let result = results.Objects\r\n      if (!result) {\r\n        return callback(new Error('expected .Objects in results'))\r\n      }\r\n\r\n      result = result[0]\r\n      if (!result) {\r\n        return callback(new Error('expected one array in results.Objects'))\r\n      }\r\n\r\n      result = result.Links\r\n      if (!Array.isArray(result)) {\r\n        return callback(new Error('expected one array in results.Objects[0].Links'))\r\n      }\r\n\r\n      result = result.map((link) => ({\r\n        name: link.Name,\r\n        path: args + '/' + link.Name,\r\n        size: link.Size,\r\n        hash: link.Hash,\r\n        type: typeOf(link),\r\n        depth: link.Depth || 1\r\n      }))\r\n\r\n      callback(null, result)\r\n    })\r\n  })\r\n}\r\n\r\nfunction typeOf (link) {\r\n  switch (link.Type) {\r\n    case 1:\r\n    case 5:\r\n      return 'dir'\r\n    case 2:\r\n      return 'file'\r\n    default:\r\n      return 'unknown'\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}