{"ast":null,"code":"'use strict';\n\nconst multihash = require('multihashes');\n\nconst crypto = require('./crypto');\n\nmodule.exports = Multihashing;\n/**\r\n * Hash the given `buf` using the algorithm specified\r\n * by `func`.\r\n *\r\n * @param {Buffer} buf - The value to hash.\r\n * @param {number|string} func - The algorithm to use.\r\n * @param {number} [length] - Optionally trim the result to this length.\r\n * @param {function(Error, Buffer)} callback\r\n * @returns {undefined}\r\n */\n\nfunction Multihashing(buf, func, length, callback) {\n  if (typeof length === 'function') {\n    callback = length;\n    length = undefined;\n  }\n\n  if (!callback) {\n    throw new Error('Missing callback');\n  }\n\n  Multihashing.digest(buf, func, length, (err, digest) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, multihash.encode(digest, func, length));\n  });\n}\n/**\r\n * The `buffer` module for easy use in the browser.\r\n *\r\n * @type {Buffer}\r\n */\n\n\nMultihashing.Buffer = Buffer; // for browser things\n\n/**\r\n * Expose multihash itself, to avoid silly double requires.\r\n */\n\nMultihashing.multihash = multihash;\n/**\r\n * @param {Buffer} buf - The value to hash.\r\n * @param {number|string} func - The algorithm to use.\r\n * @param {number} [length] - Optionally trim the result to this length.\r\n * @param {function(Error, Buffer)} callback\r\n * @returns {undefined}\r\n */\n\nMultihashing.digest = function (buf, func, length, callback) {\n  if (typeof length === 'function') {\n    callback = length;\n    length = undefined;\n  }\n\n  if (!callback) {\n    throw new Error('Missing callback');\n  }\n\n  let cb = callback;\n\n  if (length) {\n    cb = (err, digest) => {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, digest.slice(0, length));\n    };\n  }\n\n  let hash;\n\n  try {\n    hash = Multihashing.createHash(func);\n  } catch (err) {\n    return cb(err);\n  }\n\n  hash(buf, cb);\n};\n/**\r\n * @param {string|number} func\r\n *\r\n * @returns {function} - The to `func` corresponding hash function.\r\n */\n\n\nMultihashing.createHash = function (func) {\n  func = multihash.coerceCode(func);\n\n  if (!Multihashing.functions[func]) {\n    throw new Error('multihash function ' + func + ' not yet supported');\n  }\n\n  return Multihashing.functions[func];\n};\n/**\r\n * Mapping of multihash codes to their hashing functions.\r\n * @type {Object}\r\n */\n\n\nMultihashing.functions = {\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256\n}; // add blake functions\n\ncrypto.addBlake(Multihashing.functions);\n\nMultihashing.validate = (data, hash, callback) => {\n  let algo = multihash.decode(hash).name;\n  Multihashing(data, algo, (err, newHash) => {\n    if (err) return callback(err);\n    callback(err, Buffer.compare(hash, newHash) === 0);\n  });\n};","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/libp2p-crypto-secp256k1/node_modules/multihashing-async/src/index.js"],"names":["multihash","require","crypto","module","exports","Multihashing","buf","func","length","callback","undefined","Error","digest","err","encode","Buffer","cb","slice","hash","createHash","coerceCode","functions","sha1","sha2256","sha2512","sha3512","sha3384","sha3256","sha3224","shake128","shake256","keccak224","keccak256","keccak384","keccak512","murmur3128","murmur332","dblSha2256","addBlake","validate","data","algo","decode","name","newHash","compare"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst multihash = require('multihashes')\r\nconst crypto = require('./crypto')\r\n\r\nmodule.exports = Multihashing\r\n\r\n/**\r\n * Hash the given `buf` using the algorithm specified\r\n * by `func`.\r\n *\r\n * @param {Buffer} buf - The value to hash.\r\n * @param {number|string} func - The algorithm to use.\r\n * @param {number} [length] - Optionally trim the result to this length.\r\n * @param {function(Error, Buffer)} callback\r\n * @returns {undefined}\r\n */\r\nfunction Multihashing (buf, func, length, callback) {\r\n  if (typeof length === 'function') {\r\n    callback = length\r\n    length = undefined\r\n  }\r\n\r\n  if (!callback) {\r\n    throw new Error('Missing callback')\r\n  }\r\n\r\n  Multihashing.digest(buf, func, length, (err, digest) => {\r\n    if (err) {\r\n      return callback(err)\r\n    }\r\n\r\n    callback(null, multihash.encode(digest, func, length))\r\n  })\r\n}\r\n\r\n/**\r\n * The `buffer` module for easy use in the browser.\r\n *\r\n * @type {Buffer}\r\n */\r\nMultihashing.Buffer = Buffer // for browser things\r\n\r\n/**\r\n * Expose multihash itself, to avoid silly double requires.\r\n */\r\nMultihashing.multihash = multihash\r\n\r\n/**\r\n * @param {Buffer} buf - The value to hash.\r\n * @param {number|string} func - The algorithm to use.\r\n * @param {number} [length] - Optionally trim the result to this length.\r\n * @param {function(Error, Buffer)} callback\r\n * @returns {undefined}\r\n */\r\nMultihashing.digest = function (buf, func, length, callback) {\r\n  if (typeof length === 'function') {\r\n    callback = length\r\n    length = undefined\r\n  }\r\n\r\n  if (!callback) {\r\n    throw new Error('Missing callback')\r\n  }\r\n\r\n  let cb = callback\r\n  if (length) {\r\n    cb = (err, digest) => {\r\n      if (err) {\r\n        return callback(err)\r\n      }\r\n\r\n      callback(null, digest.slice(0, length))\r\n    }\r\n  }\r\n\r\n  let hash\r\n  try {\r\n    hash = Multihashing.createHash(func)\r\n  } catch (err) {\r\n    return cb(err)\r\n  }\r\n\r\n  hash(buf, cb)\r\n}\r\n\r\n/**\r\n * @param {string|number} func\r\n *\r\n * @returns {function} - The to `func` corresponding hash function.\r\n */\r\nMultihashing.createHash = function (func) {\r\n  func = multihash.coerceCode(func)\r\n  if (!Multihashing.functions[func]) {\r\n    throw new Error('multihash function ' + func + ' not yet supported')\r\n  }\r\n\r\n  return Multihashing.functions[func]\r\n}\r\n\r\n/**\r\n * Mapping of multihash codes to their hashing functions.\r\n * @type {Object}\r\n */\r\nMultihashing.functions = {\r\n  // sha1\r\n  0x11: crypto.sha1,\r\n  // sha2-256\r\n  0x12: crypto.sha2256,\r\n  // sha2-512\r\n  0x13: crypto.sha2512,\r\n  // sha3-512\r\n  0x14: crypto.sha3512,\r\n  // sha3-384\r\n  0x15: crypto.sha3384,\r\n  // sha3-256\r\n  0x16: crypto.sha3256,\r\n  // sha3-224\r\n  0x17: crypto.sha3224,\r\n  // shake-128\r\n  0x18: crypto.shake128,\r\n  // shake-256\r\n  0x19: crypto.shake256,\r\n  // keccak-224\r\n  0x1A: crypto.keccak224,\r\n  // keccak-256\r\n  0x1B: crypto.keccak256,\r\n  // keccak-384\r\n  0x1C: crypto.keccak384,\r\n  // keccak-512\r\n  0x1D: crypto.keccak512,\r\n  // murmur3-128\r\n  0x22: crypto.murmur3128,\r\n  // murmur3-32\r\n  0x23: crypto.murmur332,\r\n  // dbl-sha2-256\r\n  0x56: crypto.dblSha2256\r\n}\r\n\r\n// add blake functions\r\ncrypto.addBlake(Multihashing.functions)\r\n\r\nMultihashing.validate = (data, hash, callback) => {\r\n  let algo = multihash.decode(hash).name\r\n  Multihashing(data, algo, (err, newHash) => {\r\n    if (err) return callback(err)\r\n    callback(err, Buffer.compare(hash, newHash) === 0)\r\n  })\r\n}\r\n"]},"metadata":{},"sourceType":"script"}