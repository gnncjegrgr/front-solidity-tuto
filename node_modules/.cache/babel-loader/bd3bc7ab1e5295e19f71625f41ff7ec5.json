{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar baseX$1 = require('../../vendor/base-x.js');\n\nvar bytes = require('../bytes.js');\n\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n\n}\n\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseDecode = baseDecode;\n  }\n\n  decode(text) {\n    if (typeof text === 'string') {\n      switch (text[0]) {\n        case this.prefix:\n          {\n            return this.baseDecode(text.slice(1));\n          }\n\n        default:\n          {\n            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n          }\n      }\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n\n  or(decoder) {\n    return or(this, decoder);\n  }\n\n}\n\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n\n  or(decoder) {\n    return or(this, decoder);\n  }\n\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n    }\n  }\n\n}\n\nconst or = (left, right) => new ComposedDecoder({ ...(left.decoders || {\n    [left.prefix]: left\n  }),\n  ...(right.decoders || {\n    [right.prefix]: right\n  })\n});\n\nclass Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n\n}\n\nconst from = _ref => {\n  let {\n    name,\n    prefix,\n    encode,\n    decode\n  } = _ref;\n  return new Codec(name, prefix, encode, decode);\n};\n\nconst baseX = _ref2 => {\n  let {\n    prefix,\n    name,\n    alphabet\n  } = _ref2;\n  const {\n    encode,\n    decode\n  } = baseX$1(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => bytes.coerce(decode(text))\n  });\n};\n\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n\n  let end = string.length;\n\n  while (string[end - 1] === '=') {\n    --end;\n  }\n\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`);\n    }\n\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n\n  return out;\n};\n\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n\n  return out;\n};\n\nconst rfc4648 = _ref3 => {\n  let {\n    name,\n    prefix,\n    bitsPerChar,\n    alphabet\n  } = _ref3;\n  return from({\n    prefix,\n    name,\n\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n\n  });\n};\n\nexports.Codec = Codec;\nexports.baseX = baseX;\nexports.from = from;\nexports.or = or;\nexports.rfc4648 = rfc4648;","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/multiformats/cjs/src/bases/base.js"],"names":["Object","defineProperty","exports","value","baseX$1","require","bytes","Encoder","constructor","name","prefix","baseEncode","encode","Uint8Array","Error","Decoder","baseDecode","decode","text","slice","JSON","stringify","or","decoder","ComposedDecoder","decoders","input","RangeError","keys","left","right","Codec","encoder","from","baseX","alphabet","coerce","string","bitsPerChar","codes","i","length","end","out","bits","buffer","written","undefined","SyntaxError","data","pad","mask","rfc4648"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\nvar baseX$1 = require('../../vendor/base-x.js');\r\nvar bytes = require('../bytes.js');\r\n\r\nclass Encoder {\r\n  constructor(name, prefix, baseEncode) {\r\n    this.name = name;\r\n    this.prefix = prefix;\r\n    this.baseEncode = baseEncode;\r\n  }\r\n  encode(bytes) {\r\n    if (bytes instanceof Uint8Array) {\r\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\r\n    } else {\r\n      throw Error('Unknown type, must be binary type');\r\n    }\r\n  }\r\n}\r\nclass Decoder {\r\n  constructor(name, prefix, baseDecode) {\r\n    this.name = name;\r\n    this.prefix = prefix;\r\n    this.baseDecode = baseDecode;\r\n  }\r\n  decode(text) {\r\n    if (typeof text === 'string') {\r\n      switch (text[0]) {\r\n      case this.prefix: {\r\n          return this.baseDecode(text.slice(1));\r\n        }\r\n      default: {\r\n          throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\r\n        }\r\n      }\r\n    } else {\r\n      throw Error('Can only multibase decode strings');\r\n    }\r\n  }\r\n  or(decoder) {\r\n    return or(this, decoder);\r\n  }\r\n}\r\nclass ComposedDecoder {\r\n  constructor(decoders) {\r\n    this.decoders = decoders;\r\n  }\r\n  or(decoder) {\r\n    return or(this, decoder);\r\n  }\r\n  decode(input) {\r\n    const prefix = input[0];\r\n    const decoder = this.decoders[prefix];\r\n    if (decoder) {\r\n      return decoder.decode(input);\r\n    } else {\r\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\r\n    }\r\n  }\r\n}\r\nconst or = (left, right) => new ComposedDecoder({\r\n  ...left.decoders || { [left.prefix]: left },\r\n  ...right.decoders || { [right.prefix]: right }\r\n});\r\nclass Codec {\r\n  constructor(name, prefix, baseEncode, baseDecode) {\r\n    this.name = name;\r\n    this.prefix = prefix;\r\n    this.baseEncode = baseEncode;\r\n    this.baseDecode = baseDecode;\r\n    this.encoder = new Encoder(name, prefix, baseEncode);\r\n    this.decoder = new Decoder(name, prefix, baseDecode);\r\n  }\r\n  encode(input) {\r\n    return this.encoder.encode(input);\r\n  }\r\n  decode(input) {\r\n    return this.decoder.decode(input);\r\n  }\r\n}\r\nconst from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\r\nconst baseX = ({prefix, name, alphabet}) => {\r\n  const {encode, decode} = baseX$1(alphabet, name);\r\n  return from({\r\n    prefix,\r\n    name,\r\n    encode,\r\n    decode: text => bytes.coerce(decode(text))\r\n  });\r\n};\r\nconst decode = (string, alphabet, bitsPerChar, name) => {\r\n  const codes = {};\r\n  for (let i = 0; i < alphabet.length; ++i) {\r\n    codes[alphabet[i]] = i;\r\n  }\r\n  let end = string.length;\r\n  while (string[end - 1] === '=') {\r\n    --end;\r\n  }\r\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\r\n  let bits = 0;\r\n  let buffer = 0;\r\n  let written = 0;\r\n  for (let i = 0; i < end; ++i) {\r\n    const value = codes[string[i]];\r\n    if (value === undefined) {\r\n      throw new SyntaxError(`Non-${ name } character`);\r\n    }\r\n    buffer = buffer << bitsPerChar | value;\r\n    bits += bitsPerChar;\r\n    if (bits >= 8) {\r\n      bits -= 8;\r\n      out[written++] = 255 & buffer >> bits;\r\n    }\r\n  }\r\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\r\n    throw new SyntaxError('Unexpected end of data');\r\n  }\r\n  return out;\r\n};\r\nconst encode = (data, alphabet, bitsPerChar) => {\r\n  const pad = alphabet[alphabet.length - 1] === '=';\r\n  const mask = (1 << bitsPerChar) - 1;\r\n  let out = '';\r\n  let bits = 0;\r\n  let buffer = 0;\r\n  for (let i = 0; i < data.length; ++i) {\r\n    buffer = buffer << 8 | data[i];\r\n    bits += 8;\r\n    while (bits > bitsPerChar) {\r\n      bits -= bitsPerChar;\r\n      out += alphabet[mask & buffer >> bits];\r\n    }\r\n  }\r\n  if (bits) {\r\n    out += alphabet[mask & buffer << bitsPerChar - bits];\r\n  }\r\n  if (pad) {\r\n    while (out.length * bitsPerChar & 7) {\r\n      out += '=';\r\n    }\r\n  }\r\n  return out;\r\n};\r\nconst rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\r\n  return from({\r\n    prefix,\r\n    name,\r\n    encode(input) {\r\n      return encode(input, alphabet, bitsPerChar);\r\n    },\r\n    decode(input) {\r\n      return decode(input, alphabet, bitsPerChar, name);\r\n    }\r\n  });\r\n};\r\n\r\nexports.Codec = Codec;\r\nexports.baseX = baseX;\r\nexports.from = from;\r\nexports.or = or;\r\nexports.rfc4648 = rfc4648;\r\n"]},"metadata":{},"sourceType":"script"}