{"ast":null,"code":"'use strict';\n\nconst {\n  objectToQuery\n} = require('../lib/querystring');\n\nconst configure = require('../lib/configure');\n\nconst {\n  ok\n} = require('../lib/fetch');\n\nconst toCamel = require('../lib/to-camel');\n\nmodule.exports = configure(_ref => {\n  let {\n    fetch,\n    apiUrl,\n    apiPath,\n    headers\n  } = _ref;\n  return async options => {\n    options = options || {};\n    const qs = objectToQuery({\n      verbose: options.verbose,\n      streams: options.streams,\n      latency: options.latency,\n      ...(options.qs || {})\n    });\n    const url = `${apiUrl}${apiPath}/swarm/peers${qs}`;\n    const res = await ok(fetch(url, {\n      signal: options.signal,\n      headers: options.headers || headers\n    }));\n    const data = await res.json();\n    return (data.Peers || []).map(p => {\n      const peerInfo = toCamel(p);\n\n      if (peerInfo.streams) {\n        peerInfo.streams = peerInfo.streams.map(toCamel);\n      }\n\n      return peerInfo;\n    });\n  };\n});","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/ipfs-http-client-lite/src/swarm/peers.js"],"names":["objectToQuery","require","configure","ok","toCamel","module","exports","fetch","apiUrl","apiPath","headers","options","qs","verbose","streams","latency","url","res","signal","data","json","Peers","map","p","peerInfo"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAoBC,OAAO,CAAC,oBAAD,CAAjC;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,kBAAD,CAAzB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAASF,OAAO,CAAC,cAAD,CAAtB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,iBAAD,CAAvB;;AAEAI,MAAM,CAACC,OAAP,GAAiBJ,SAAS,CAAC,QAAyC;AAAA,MAAxC;AAAEK,IAAAA,KAAF;AAASC,IAAAA,MAAT;AAAiBC,IAAAA,OAAjB;AAA0BC,IAAAA;AAA1B,GAAwC;AAClE,SAAO,MAAMC,OAAN,IAAiB;AACtBA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,UAAMC,EAAE,GAAGZ,aAAa,CAAC;AACvBa,MAAAA,OAAO,EAAEF,OAAO,CAACE,OADM;AAEvBC,MAAAA,OAAO,EAAEH,OAAO,CAACG,OAFM;AAGvBC,MAAAA,OAAO,EAAEJ,OAAO,CAACI,OAHM;AAIvB,UAAIJ,OAAO,CAACC,EAAR,IAAc,EAAlB;AAJuB,KAAD,CAAxB;AAOA,UAAMI,GAAG,GAAI,GAAER,MAAO,GAAEC,OAAQ,eAAcG,EAAG,EAAjD;AACA,UAAMK,GAAG,GAAG,MAAMd,EAAE,CAACI,KAAK,CAACS,GAAD,EAAM;AAC9BE,MAAAA,MAAM,EAAEP,OAAO,CAACO,MADc;AAE9BR,MAAAA,OAAO,EAAEC,OAAO,CAACD,OAAR,IAAmBA;AAFE,KAAN,CAAN,CAApB;AAIA,UAAMS,IAAI,GAAG,MAAMF,GAAG,CAACG,IAAJ,EAAnB;AAEA,WAAO,CAACD,IAAI,CAACE,KAAL,IAAc,EAAf,EAAmBC,GAAnB,CAAuBC,CAAC,IAAI;AACjC,YAAMC,QAAQ,GAAGpB,OAAO,CAACmB,CAAD,CAAxB;;AAEA,UAAIC,QAAQ,CAACV,OAAb,EAAsB;AACpBU,QAAAA,QAAQ,CAACV,OAAT,GAAmBU,QAAQ,CAACV,OAAT,CAAiBQ,GAAjB,CAAqBlB,OAArB,CAAnB;AACD;;AAED,aAAOoB,QAAP;AACD,KARM,CAAP;AASD,GA1BD;AA2BD,CA5ByB,CAA1B","sourcesContent":["'use strict'\r\n\r\nconst { objectToQuery } = require('../lib/querystring')\r\nconst configure = require('../lib/configure')\r\nconst { ok } = require('../lib/fetch')\r\nconst toCamel = require('../lib/to-camel')\r\n\r\nmodule.exports = configure(({ fetch, apiUrl, apiPath, headers }) => {\r\n  return async options => {\r\n    options = options || {}\r\n\r\n    const qs = objectToQuery({\r\n      verbose: options.verbose,\r\n      streams: options.streams,\r\n      latency: options.latency,\r\n      ...(options.qs || {})\r\n    })\r\n\r\n    const url = `${apiUrl}${apiPath}/swarm/peers${qs}`\r\n    const res = await ok(fetch(url, {\r\n      signal: options.signal,\r\n      headers: options.headers || headers\r\n    }))\r\n    const data = await res.json()\r\n\r\n    return (data.Peers || []).map(p => {\r\n      const peerInfo = toCamel(p)\r\n\r\n      if (peerInfo.streams) {\r\n        peerInfo.streams = peerInfo.streams.map(toCamel)\r\n      }\r\n\r\n      return peerInfo\r\n    })\r\n  }\r\n})\r\n"]},"metadata":{},"sourceType":"script"}