{"ast":null,"code":"'use strict';\n\nconst {\n  Duplex\n} = require('readable-stream');\n\nconst eachSeries = require('async/eachSeries');\n\nconst isStream = require('is-stream');\n\nconst once = require('once');\n\nconst prepareFile = require('./prepare-file');\n\nconst Multipart = require('./multipart');\n\nfunction headers(file) {\n  const name = file.path ? encodeURIComponent(file.path) : '';\n  const header = {\n    'Content-Disposition': `file; filename=\"${name}\"`\n  };\n\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory';\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink';\n  } else {\n    header['Content-Type'] = 'application/octet-stream';\n  }\n\n  return header;\n}\n\nmodule.exports = (send, path) => {\n  return options => {\n    let request;\n    let ended = false;\n    let writing = false;\n    options = options ? Object.assign({}, options, options.qs) : {};\n    const multipart = new Multipart();\n    const retStream = new Duplex({\n      objectMode: true\n    });\n\n    retStream._read = n => {};\n\n    retStream._write = (file, enc, _next) => {\n      const next = once(_next);\n\n      try {\n        const files = prepareFile(file, options).map(file => Object.assign({\n          headers: headers(file)\n        }, file));\n        writing = true;\n        eachSeries(files, (file, cb) => multipart.write(file, enc, cb), err => {\n          writing = false;\n\n          if (err) {\n            return next(err);\n          }\n\n          if (ended) {\n            multipart.end();\n          }\n\n          next();\n        });\n      } catch (err) {\n        next(err);\n      }\n    };\n\n    retStream.once('finish', () => {\n      if (!ended) {\n        ended = true;\n\n        if (!writing) {\n          multipart.end();\n        }\n      }\n    });\n    const qs = options.qs || {};\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion');\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves');\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash');\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory');\n    qs.hash = propOrProp(options, 'hash', 'hashAlg');\n\n    if (options.strategy === 'trickle' || options.trickle) {\n      qs['trickle'] = 'true';\n    }\n\n    const args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    };\n    multipart.on('error', err => {\n      retStream.emit('error', err);\n    });\n    request = send(args, (err, response) => {\n      if (err) {\n        return retStream.emit('error', err);\n      }\n\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null); // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response);\n        retStream.push(null);\n        return;\n      }\n\n      response.on('error', err => retStream.emit('error', err));\n\n      if (options.converter) {\n        response.on('data', d => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n        });\n        const Converter = options.converter;\n        const convertedResponse = new Converter();\n        convertedResponse.once('end', () => retStream.push(null));\n        convertedResponse.on('data', d => retStream.push(d));\n        response.pipe(convertedResponse);\n      } else {\n        response.on('data', d => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n\n          retStream.push(d);\n        });\n        response.once('end', () => retStream.push(null));\n      }\n    }); // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n\n    request.on('drain', () => multipart.emit('drain'));\n    multipart.pipe(request);\n    return retStream;\n  };\n};\n\nfunction propOrProp(source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1];\n  } else if (prop2 in source) {\n    return source[prop2];\n  }\n}","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/ipfs-http-client/src/utils/send-files-stream.js"],"names":["Duplex","require","eachSeries","isStream","once","prepareFile","Multipart","headers","file","name","path","encodeURIComponent","header","content","symlink","module","exports","send","options","request","ended","writing","Object","assign","qs","multipart","retStream","objectMode","_read","n","_write","enc","_next","next","files","map","cb","write","err","end","propOrProp","hash","strategy","trickle","args","multipartBoundary","_boundary","stream","recursive","progress","on","emit","response","push","converter","d","Bytes","Converter","convertedResponse","pipe","source","prop1","prop2"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,iBAAD,CAA1B;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,kBAAD,CAA1B;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAMK,SAAS,GAAGL,OAAO,CAAC,aAAD,CAAzB;;AAEA,SAASM,OAAT,CAAkBC,IAAlB,EAAwB;AACtB,QAAMC,IAAI,GAAGD,IAAI,CAACE,IAAL,GACTC,kBAAkB,CAACH,IAAI,CAACE,IAAN,CADT,GAET,EAFJ;AAIA,QAAME,MAAM,GAAG;AAAE,2BAAwB,mBAAkBH,IAAK;AAAjD,GAAf;;AAEA,MAAI,CAACD,IAAI,CAACK,OAAV,EAAmB;AACjBD,IAAAA,MAAM,CAAC,cAAD,CAAN,GAAyB,yBAAzB;AACD,GAFD,MAEO,IAAIJ,IAAI,CAACM,OAAT,EAAkB;AACvBF,IAAAA,MAAM,CAAC,cAAD,CAAN,GAAyB,qBAAzB;AACD,GAFM,MAEA;AACLA,IAAAA,MAAM,CAAC,cAAD,CAAN,GAAyB,0BAAzB;AACD;;AAED,SAAOA,MAAP;AACD;;AAEDG,MAAM,CAACC,OAAP,GAAiB,CAACC,IAAD,EAAOP,IAAP,KAAgB;AAC/B,SAAQQ,OAAD,IAAa;AAClB,QAAIC,OAAJ;AACA,QAAIC,KAAK,GAAG,KAAZ;AACA,QAAIC,OAAO,GAAG,KAAd;AAEAH,IAAAA,OAAO,GAAGA,OAAO,GAAGI,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,OAAlB,EAA2BA,OAAO,CAACM,EAAnC,CAAH,GAA4C,EAA7D;AAEA,UAAMC,SAAS,GAAG,IAAInB,SAAJ,EAAlB;AAEA,UAAMoB,SAAS,GAAG,IAAI1B,MAAJ,CAAW;AAAE2B,MAAAA,UAAU,EAAE;AAAd,KAAX,CAAlB;;AAEAD,IAAAA,SAAS,CAACE,KAAV,GAAmBC,CAAD,IAAO,CAAE,CAA3B;;AAEAH,IAAAA,SAAS,CAACI,MAAV,GAAmB,CAACtB,IAAD,EAAOuB,GAAP,EAAYC,KAAZ,KAAsB;AACvC,YAAMC,IAAI,GAAG7B,IAAI,CAAC4B,KAAD,CAAjB;;AACA,UAAI;AACF,cAAME,KAAK,GAAG7B,WAAW,CAACG,IAAD,EAAOU,OAAP,CAAX,CACXiB,GADW,CACN3B,IAAD,IAAUc,MAAM,CAACC,MAAP,CAAc;AAAEhB,UAAAA,OAAO,EAAEA,OAAO,CAACC,IAAD;AAAlB,SAAd,EAA0CA,IAA1C,CADH,CAAd;AAGAa,QAAAA,OAAO,GAAG,IAAV;AACAnB,QAAAA,UAAU,CACRgC,KADQ,EAER,CAAC1B,IAAD,EAAO4B,EAAP,KAAcX,SAAS,CAACY,KAAV,CAAgB7B,IAAhB,EAAsBuB,GAAtB,EAA2BK,EAA3B,CAFN,EAGPE,GAAD,IAAS;AACPjB,UAAAA,OAAO,GAAG,KAAV;;AACA,cAAIiB,GAAJ,EAAS;AACP,mBAAOL,IAAI,CAACK,GAAD,CAAX;AACD;;AACD,cAAIlB,KAAJ,EAAW;AACTK,YAAAA,SAAS,CAACc,GAAV;AACD;;AACDN,UAAAA,IAAI;AACL,SAZO,CAAV;AAaD,OAlBD,CAkBE,OAAOK,GAAP,EAAY;AACZL,QAAAA,IAAI,CAACK,GAAD,CAAJ;AACD;AACF,KAvBD;;AAyBAZ,IAAAA,SAAS,CAACtB,IAAV,CAAe,QAAf,EAAyB,MAAM;AAC7B,UAAI,CAACgB,KAAL,EAAY;AACVA,QAAAA,KAAK,GAAG,IAAR;;AACA,YAAI,CAACC,OAAL,EAAc;AACZI,UAAAA,SAAS,CAACc,GAAV;AACD;AACF;AACF,KAPD;AASA,UAAMf,EAAE,GAAGN,OAAO,CAACM,EAAR,IAAc,EAAzB;AAEAA,IAAAA,EAAE,CAAC,aAAD,CAAF,GAAoBgB,UAAU,CAACtB,OAAD,EAAU,aAAV,EAAyB,YAAzB,CAA9B;AACAM,IAAAA,EAAE,CAAC,YAAD,CAAF,GAAmBgB,UAAU,CAACtB,OAAD,EAAU,YAAV,EAAwB,WAAxB,CAA7B;AACAM,IAAAA,EAAE,CAAC,WAAD,CAAF,GAAkBgB,UAAU,CAACtB,OAAD,EAAU,WAAV,EAAuB,UAAvB,CAA5B;AACAM,IAAAA,EAAE,CAAC,qBAAD,CAAF,GAA4BgB,UAAU,CAACtB,OAAD,EAAU,qBAAV,EAAiC,mBAAjC,CAAtC;AACAM,IAAAA,EAAE,CAACiB,IAAH,GAAUD,UAAU,CAACtB,OAAD,EAAU,MAAV,EAAkB,SAAlB,CAApB;;AAEA,QAAIA,OAAO,CAACwB,QAAR,KAAqB,SAArB,IAAkCxB,OAAO,CAACyB,OAA9C,EAAuD;AACrDnB,MAAAA,EAAE,CAAC,SAAD,CAAF,GAAgB,MAAhB;AACD;;AAED,UAAMoB,IAAI,GAAG;AACXlC,MAAAA,IAAI,EAAEA,IADK;AAEXc,MAAAA,EAAE,EAAEA,EAFO;AAGXoB,MAAAA,IAAI,EAAE1B,OAAO,CAAC0B,IAHH;AAIXnB,MAAAA,SAAS,EAAE,IAJA;AAKXoB,MAAAA,iBAAiB,EAAEpB,SAAS,CAACqB,SALlB;AAMXC,MAAAA,MAAM,EAAE,IANG;AAOXC,MAAAA,SAAS,EAAE,IAPA;AAQXC,MAAAA,QAAQ,EAAE/B,OAAO,CAAC+B;AARP,KAAb;AAWAxB,IAAAA,SAAS,CAACyB,EAAV,CAAa,OAAb,EAAuBZ,GAAD,IAAS;AAC7BZ,MAAAA,SAAS,CAACyB,IAAV,CAAe,OAAf,EAAwBb,GAAxB;AACD,KAFD;AAIAnB,IAAAA,OAAO,GAAGF,IAAI,CAAC2B,IAAD,EAAO,CAACN,GAAD,EAAMc,QAAN,KAAmB;AACtC,UAAId,GAAJ,EAAS;AACP,eAAOZ,SAAS,CAACyB,IAAV,CAAe,OAAf,EAAwBb,GAAxB,CAAP;AACD;;AAED,UAAI,CAACc,QAAL,EAAe;AACb;AACA,eAAO1B,SAAS,CAAC2B,IAAV,CAAe,IAAf,CAAP,CAFa,CAEe;AAC7B;;AAED,UAAI,CAAClD,QAAQ,CAACiD,QAAD,CAAb,EAAyB;AACvB1B,QAAAA,SAAS,CAAC2B,IAAV,CAAeD,QAAf;AACA1B,QAAAA,SAAS,CAAC2B,IAAV,CAAe,IAAf;AACA;AACD;;AAEDD,MAAAA,QAAQ,CAACF,EAAT,CAAY,OAAZ,EAAsBZ,GAAD,IAASZ,SAAS,CAACyB,IAAV,CAAe,OAAf,EAAwBb,GAAxB,CAA9B;;AAEA,UAAIpB,OAAO,CAACoC,SAAZ,EAAuB;AACrBF,QAAAA,QAAQ,CAACF,EAAT,CAAY,MAAZ,EAAqBK,CAAD,IAAO;AACzB,cAAIA,CAAC,CAACC,KAAF,IAAWtC,OAAO,CAAC+B,QAAvB,EAAiC;AAC/B/B,YAAAA,OAAO,CAAC+B,QAAR,CAAiBM,CAAC,CAACC,KAAnB;AACD;AACF,SAJD;AAMA,cAAMC,SAAS,GAAGvC,OAAO,CAACoC,SAA1B;AACA,cAAMI,iBAAiB,GAAG,IAAID,SAAJ,EAA1B;AACAC,QAAAA,iBAAiB,CAACtD,IAAlB,CAAuB,KAAvB,EAA8B,MAAMsB,SAAS,CAAC2B,IAAV,CAAe,IAAf,CAApC;AACAK,QAAAA,iBAAiB,CAACR,EAAlB,CAAqB,MAArB,EAA8BK,CAAD,IAAO7B,SAAS,CAAC2B,IAAV,CAAeE,CAAf,CAApC;AACAH,QAAAA,QAAQ,CAACO,IAAT,CAAcD,iBAAd;AACD,OAZD,MAYO;AACLN,QAAAA,QAAQ,CAACF,EAAT,CAAY,MAAZ,EAAqBK,CAAD,IAAO;AACzB,cAAIA,CAAC,CAACC,KAAF,IAAWtC,OAAO,CAAC+B,QAAvB,EAAiC;AAC/B/B,YAAAA,OAAO,CAAC+B,QAAR,CAAiBM,CAAC,CAACC,KAAnB;AACD;;AACD9B,UAAAA,SAAS,CAAC2B,IAAV,CAAeE,CAAf;AACD,SALD;AAMAH,QAAAA,QAAQ,CAAChD,IAAT,CAAc,KAAd,EAAqB,MAAMsB,SAAS,CAAC2B,IAAV,CAAe,IAAf,CAA3B;AACD;AACF,KAvCa,CAAd,CA1EkB,CAmHlB;AACA;;AACAlC,IAAAA,OAAO,CAAC+B,EAAR,CAAW,OAAX,EAAoB,MAAMzB,SAAS,CAAC0B,IAAV,CAAe,OAAf,CAA1B;AAEA1B,IAAAA,SAAS,CAACkC,IAAV,CAAexC,OAAf;AAEA,WAAOO,SAAP;AACD,GA1HD;AA2HD,CA5HD;;AA8HA,SAASc,UAAT,CAAqBoB,MAArB,EAA6BC,KAA7B,EAAoCC,KAApC,EAA2C;AACzC,MAAID,KAAK,IAAID,MAAb,EAAqB;AACnB,WAAOA,MAAM,CAACC,KAAD,CAAb;AACD,GAFD,MAEO,IAAIC,KAAK,IAAIF,MAAb,EAAqB;AAC1B,WAAOA,MAAM,CAACE,KAAD,CAAb;AACD;AACF","sourcesContent":["'use strict'\r\n\r\nconst { Duplex } = require('readable-stream')\r\nconst eachSeries = require('async/eachSeries')\r\nconst isStream = require('is-stream')\r\nconst once = require('once')\r\nconst prepareFile = require('./prepare-file')\r\nconst Multipart = require('./multipart')\r\n\r\nfunction headers (file) {\r\n  const name = file.path\r\n    ? encodeURIComponent(file.path)\r\n    : ''\r\n\r\n  const header = { 'Content-Disposition': `file; filename=\"${name}\"` }\r\n\r\n  if (!file.content) {\r\n    header['Content-Type'] = 'application/x-directory'\r\n  } else if (file.symlink) {\r\n    header['Content-Type'] = 'application/symlink'\r\n  } else {\r\n    header['Content-Type'] = 'application/octet-stream'\r\n  }\r\n\r\n  return header\r\n}\r\n\r\nmodule.exports = (send, path) => {\r\n  return (options) => {\r\n    let request\r\n    let ended = false\r\n    let writing = false\r\n\r\n    options = options ? Object.assign({}, options, options.qs) : {}\r\n\r\n    const multipart = new Multipart()\r\n\r\n    const retStream = new Duplex({ objectMode: true })\r\n\r\n    retStream._read = (n) => {}\r\n\r\n    retStream._write = (file, enc, _next) => {\r\n      const next = once(_next)\r\n      try {\r\n        const files = prepareFile(file, options)\r\n          .map((file) => Object.assign({ headers: headers(file) }, file))\r\n\r\n        writing = true\r\n        eachSeries(\r\n          files,\r\n          (file, cb) => multipart.write(file, enc, cb),\r\n          (err) => {\r\n            writing = false\r\n            if (err) {\r\n              return next(err)\r\n            }\r\n            if (ended) {\r\n              multipart.end()\r\n            }\r\n            next()\r\n          })\r\n      } catch (err) {\r\n        next(err)\r\n      }\r\n    }\r\n\r\n    retStream.once('finish', () => {\r\n      if (!ended) {\r\n        ended = true\r\n        if (!writing) {\r\n          multipart.end()\r\n        }\r\n      }\r\n    })\r\n\r\n    const qs = options.qs || {}\r\n\r\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion')\r\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves')\r\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash')\r\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory')\r\n    qs.hash = propOrProp(options, 'hash', 'hashAlg')\r\n\r\n    if (options.strategy === 'trickle' || options.trickle) {\r\n      qs['trickle'] = 'true'\r\n    }\r\n\r\n    const args = {\r\n      path: path,\r\n      qs: qs,\r\n      args: options.args,\r\n      multipart: true,\r\n      multipartBoundary: multipart._boundary,\r\n      stream: true,\r\n      recursive: true,\r\n      progress: options.progress\r\n    }\r\n\r\n    multipart.on('error', (err) => {\r\n      retStream.emit('error', err)\r\n    })\r\n\r\n    request = send(args, (err, response) => {\r\n      if (err) {\r\n        return retStream.emit('error', err)\r\n      }\r\n\r\n      if (!response) {\r\n        // no response, which means everything is ok, so we end the retStream\r\n        return retStream.push(null) // early\r\n      }\r\n\r\n      if (!isStream(response)) {\r\n        retStream.push(response)\r\n        retStream.push(null)\r\n        return\r\n      }\r\n\r\n      response.on('error', (err) => retStream.emit('error', err))\r\n\r\n      if (options.converter) {\r\n        response.on('data', (d) => {\r\n          if (d.Bytes && options.progress) {\r\n            options.progress(d.Bytes)\r\n          }\r\n        })\r\n\r\n        const Converter = options.converter\r\n        const convertedResponse = new Converter()\r\n        convertedResponse.once('end', () => retStream.push(null))\r\n        convertedResponse.on('data', (d) => retStream.push(d))\r\n        response.pipe(convertedResponse)\r\n      } else {\r\n        response.on('data', (d) => {\r\n          if (d.Bytes && options.progress) {\r\n            options.progress(d.Bytes)\r\n          }\r\n          retStream.push(d)\r\n        })\r\n        response.once('end', () => retStream.push(null))\r\n      }\r\n    })\r\n\r\n    // signal the multipart that the underlying stream has drained and that\r\n    // it can continue producing data..\r\n    request.on('drain', () => multipart.emit('drain'))\r\n\r\n    multipart.pipe(request)\r\n\r\n    return retStream\r\n  }\r\n}\r\n\r\nfunction propOrProp (source, prop1, prop2) {\r\n  if (prop1 in source) {\r\n    return source[prop1]\r\n  } else if (prop2 in source) {\r\n    return source[prop2]\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}