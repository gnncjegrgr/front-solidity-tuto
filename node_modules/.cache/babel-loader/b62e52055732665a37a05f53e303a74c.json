{"ast":null,"code":"'use strict';\n\nconst promisify = require('promisify-es6');\n\nconst EventEmitter = require('events');\n\nconst eos = require('end-of-stream');\n\nconst isNode = require('detect-node');\n\nconst setImmediate = require('async/setImmediate');\n\nconst PubsubMessageStream = require('./utils/pubsub-message-stream');\n\nconst stringlistToArray = require('./utils/stringlist-to-array');\n\nconst moduleConfig = require('./utils/module-config');\n\nconst NotSupportedError = () => new Error('pubsub is currently not supported when run in the browser');\n/* Public API */\n\n\nmodule.exports = arg => {\n  const send = moduleConfig(arg);\n  /* Internal subscriptions state and functions */\n\n  const ps = new EventEmitter();\n  const subscriptions = {};\n  ps.id = Math.random();\n  return {\n    subscribe: (topic, handler, options, callback) => {\n      const defaultOptions = {\n        discover: false\n      };\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = defaultOptions;\n      }\n\n      if (!options) {\n        options = defaultOptions;\n      } // Throw an error if ran in the browsers\n\n\n      if (!isNode) {\n        if (!callback) {\n          return Promise.reject(NotSupportedError());\n        }\n\n        return setImmediate(() => callback(NotSupportedError()));\n      } // promisify doesn't work as we always pass a\n      // function as last argument (`handler`)\n\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          subscribe(topic, handler, options, err => {\n            if (err) {\n              return reject(err);\n            }\n\n            resolve();\n          });\n        });\n      }\n\n      subscribe(topic, handler, options, callback);\n    },\n    unsubscribe: (topic, handler, callback) => {\n      if (!isNode) {\n        if (!callback) {\n          return Promise.reject(NotSupportedError());\n        }\n\n        return setImmediate(() => callback(NotSupportedError()));\n      }\n\n      if (ps.listenerCount(topic) === 0 || !subscriptions[topic]) {\n        const err = new Error(`Not subscribed to '${topic}'`);\n\n        if (!callback) {\n          return Promise.reject(err);\n        }\n\n        return setImmediate(() => callback(err));\n      }\n\n      if (!handler && !callback) {\n        ps.removeAllListeners(topic);\n      } else {\n        ps.removeListener(topic, handler);\n      } // Drop the request once we are actually done\n\n\n      if (ps.listenerCount(topic) === 0) {\n        if (!callback) {\n          return new Promise((resolve, reject) => {\n            // When the response stream has ended, resolve the promise\n            eos(subscriptions[topic].res, err => {\n              // FIXME: Artificial timeout needed to ensure unsubscribed\n              setTimeout(() => {\n                if (err) return reject(err);\n                resolve();\n              });\n            });\n            subscriptions[topic].req.abort();\n            subscriptions[topic] = null;\n          });\n        } // When the response stream has ended, call the callback\n\n\n        eos(subscriptions[topic].res, err => {\n          // FIXME: Artificial timeout needed to ensure unsubscribed\n          setTimeout(() => callback(err));\n        });\n        subscriptions[topic].req.abort();\n        subscriptions[topic] = null;\n        return;\n      }\n\n      if (!callback) {\n        return Promise.resolve();\n      }\n\n      setImmediate(() => callback());\n    },\n    publish: promisify((topic, data, callback) => {\n      if (!isNode) {\n        return callback(NotSupportedError());\n      }\n\n      if (!Buffer.isBuffer(data)) {\n        return callback(new Error('data must be a Buffer'));\n      }\n\n      const request = {\n        path: 'pubsub/pub',\n        args: [topic, data]\n      };\n      send(request, callback);\n    }),\n    ls: promisify(callback => {\n      if (!isNode) {\n        return callback(NotSupportedError());\n      }\n\n      const request = {\n        path: 'pubsub/ls'\n      };\n      send.andTransform(request, stringlistToArray, callback);\n    }),\n    peers: promisify((topic, callback) => {\n      if (!isNode) {\n        return callback(NotSupportedError());\n      }\n\n      const request = {\n        path: 'pubsub/peers',\n        args: [topic]\n      };\n      send.andTransform(request, stringlistToArray, callback);\n    }),\n\n    setMaxListeners(n) {\n      return ps.setMaxListeners(n);\n    }\n\n  };\n\n  function subscribe(topic, handler, options, callback) {\n    ps.on(topic, handler);\n\n    if (subscriptions[topic]) {\n      // TODO: should a callback error be returned?\n      return callback();\n    } // Request params\n\n\n    const request = {\n      path: 'pubsub/sub',\n      args: [topic],\n      qs: {\n        discover: options.discover\n      }\n    }; // Start the request and transform the response\n    // stream to Pubsub messages stream\n\n    subscriptions[topic] = {};\n    subscriptions[topic].req = send.andTransform(request, PubsubMessageStream.from, (err, stream) => {\n      if (err) {\n        subscriptions[topic] = null;\n        ps.removeListener(topic, handler);\n        return callback(err);\n      }\n\n      subscriptions[topic].res = stream;\n      stream.on('data', msg => {\n        ps.emit(topic, msg);\n      });\n      stream.on('error', err => {\n        ps.emit('error', err);\n      });\n      eos(stream, err => {\n        if (err) {\n          ps.emit('error', err);\n        }\n\n        subscriptions[topic] = null;\n        ps.removeListener(topic, handler);\n      });\n      callback();\n    });\n  }\n};","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/ipfs-http-client/src/pubsub.js"],"names":["promisify","require","EventEmitter","eos","isNode","setImmediate","PubsubMessageStream","stringlistToArray","moduleConfig","NotSupportedError","Error","module","exports","arg","send","ps","subscriptions","id","Math","random","subscribe","topic","handler","options","callback","defaultOptions","discover","Promise","reject","resolve","err","unsubscribe","listenerCount","removeAllListeners","removeListener","res","setTimeout","req","abort","publish","data","Buffer","isBuffer","request","path","args","ls","andTransform","peers","setMaxListeners","n","on","qs","from","stream","msg","emit"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst promisify = require('promisify-es6')\r\nconst EventEmitter = require('events')\r\nconst eos = require('end-of-stream')\r\nconst isNode = require('detect-node')\r\nconst setImmediate = require('async/setImmediate')\r\nconst PubsubMessageStream = require('./utils/pubsub-message-stream')\r\nconst stringlistToArray = require('./utils/stringlist-to-array')\r\nconst moduleConfig = require('./utils/module-config')\r\n\r\nconst NotSupportedError = () => new Error('pubsub is currently not supported when run in the browser')\r\n\r\n/* Public API */\r\nmodule.exports = (arg) => {\r\n  const send = moduleConfig(arg)\r\n\r\n  /* Internal subscriptions state and functions */\r\n  const ps = new EventEmitter()\r\n  const subscriptions = {}\r\n  ps.id = Math.random()\r\n  return {\r\n    subscribe: (topic, handler, options, callback) => {\r\n      const defaultOptions = {\r\n        discover: false\r\n      }\r\n\r\n      if (typeof options === 'function') {\r\n        callback = options\r\n        options = defaultOptions\r\n      }\r\n\r\n      if (!options) {\r\n        options = defaultOptions\r\n      }\r\n\r\n      // Throw an error if ran in the browsers\r\n      if (!isNode) {\r\n        if (!callback) {\r\n          return Promise.reject(NotSupportedError())\r\n        }\r\n\r\n        return setImmediate(() => callback(NotSupportedError()))\r\n      }\r\n\r\n      // promisify doesn't work as we always pass a\r\n      // function as last argument (`handler`)\r\n      if (!callback) {\r\n        return new Promise((resolve, reject) => {\r\n          subscribe(topic, handler, options, (err) => {\r\n            if (err) {\r\n              return reject(err)\r\n            }\r\n            resolve()\r\n          })\r\n        })\r\n      }\r\n\r\n      subscribe(topic, handler, options, callback)\r\n    },\r\n    unsubscribe: (topic, handler, callback) => {\r\n      if (!isNode) {\r\n        if (!callback) {\r\n          return Promise.reject(NotSupportedError())\r\n        }\r\n\r\n        return setImmediate(() => callback(NotSupportedError()))\r\n      }\r\n\r\n      if (ps.listenerCount(topic) === 0 || !subscriptions[topic]) {\r\n        const err = new Error(`Not subscribed to '${topic}'`)\r\n\r\n        if (!callback) {\r\n          return Promise.reject(err)\r\n        }\r\n\r\n        return setImmediate(() => callback(err))\r\n      }\r\n\r\n      if (!handler && !callback) {\r\n        ps.removeAllListeners(topic)\r\n      } else {\r\n        ps.removeListener(topic, handler)\r\n      }\r\n\r\n      // Drop the request once we are actually done\r\n      if (ps.listenerCount(topic) === 0) {\r\n        if (!callback) {\r\n          return new Promise((resolve, reject) => {\r\n            // When the response stream has ended, resolve the promise\r\n            eos(subscriptions[topic].res, (err) => {\r\n              // FIXME: Artificial timeout needed to ensure unsubscribed\r\n              setTimeout(() => {\r\n                if (err) return reject(err)\r\n                resolve()\r\n              })\r\n            })\r\n            subscriptions[topic].req.abort()\r\n            subscriptions[topic] = null\r\n          })\r\n        }\r\n\r\n        // When the response stream has ended, call the callback\r\n        eos(subscriptions[topic].res, (err) => {\r\n          // FIXME: Artificial timeout needed to ensure unsubscribed\r\n          setTimeout(() => callback(err))\r\n        })\r\n        subscriptions[topic].req.abort()\r\n        subscriptions[topic] = null\r\n        return\r\n      }\r\n\r\n      if (!callback) {\r\n        return Promise.resolve()\r\n      }\r\n\r\n      setImmediate(() => callback())\r\n    },\r\n    publish: promisify((topic, data, callback) => {\r\n      if (!isNode) {\r\n        return callback(NotSupportedError())\r\n      }\r\n\r\n      if (!Buffer.isBuffer(data)) {\r\n        return callback(new Error('data must be a Buffer'))\r\n      }\r\n\r\n      const request = {\r\n        path: 'pubsub/pub',\r\n        args: [topic, data]\r\n      }\r\n\r\n      send(request, callback)\r\n    }),\r\n    ls: promisify((callback) => {\r\n      if (!isNode) {\r\n        return callback(NotSupportedError())\r\n      }\r\n\r\n      const request = {\r\n        path: 'pubsub/ls'\r\n      }\r\n\r\n      send.andTransform(request, stringlistToArray, callback)\r\n    }),\r\n    peers: promisify((topic, callback) => {\r\n      if (!isNode) {\r\n        return callback(NotSupportedError())\r\n      }\r\n\r\n      const request = {\r\n        path: 'pubsub/peers',\r\n        args: [topic]\r\n      }\r\n\r\n      send.andTransform(request, stringlistToArray, callback)\r\n    }),\r\n    setMaxListeners (n) {\r\n      return ps.setMaxListeners(n)\r\n    }\r\n  }\r\n\r\n  function subscribe (topic, handler, options, callback) {\r\n    ps.on(topic, handler)\r\n\r\n    if (subscriptions[topic]) {\r\n      // TODO: should a callback error be returned?\r\n      return callback()\r\n    }\r\n\r\n    // Request params\r\n    const request = {\r\n      path: 'pubsub/sub',\r\n      args: [topic],\r\n      qs: {\r\n        discover: options.discover\r\n      }\r\n    }\r\n\r\n    // Start the request and transform the response\r\n    // stream to Pubsub messages stream\r\n    subscriptions[topic] = {}\r\n    subscriptions[topic].req = send.andTransform(request, PubsubMessageStream.from, (err, stream) => {\r\n      if (err) {\r\n        subscriptions[topic] = null\r\n        ps.removeListener(topic, handler)\r\n        return callback(err)\r\n      }\r\n\r\n      subscriptions[topic].res = stream\r\n\r\n      stream.on('data', (msg) => {\r\n        ps.emit(topic, msg)\r\n      })\r\n\r\n      stream.on('error', (err) => {\r\n        ps.emit('error', err)\r\n      })\r\n\r\n      eos(stream, (err) => {\r\n        if (err) {\r\n          ps.emit('error', err)\r\n        }\r\n\r\n        subscriptions[topic] = null\r\n        ps.removeListener(topic, handler)\r\n      })\r\n\r\n      callback()\r\n    })\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}