{"ast":null,"code":"/*\r\n    Modifications copyright 2018 The caver-js Authors\r\n    This file is part of web3.js.\r\n\r\n    web3.js is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    web3.js is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n    This file is derived from web3.js/packages/web3-core-subscriptions/src/subscription.js (2019/06/12).\r\n    Modified and improved for the caver-js development.\r\n*/\n\n/**\r\n * @file subscription.js\r\n * @author Fabian Vogelsteller <fabian@ethereum.org>\r\n * @date 2017\r\n */\nconst _ = require('lodash');\n\nconst EventEmitter = require('eventemitter3');\n\nconst errors = require('../../caver-core-helpers').errors;\n/**\r\n * @classdesc A subscription class implemented to subscribe the specific events in the blockchain.\r\n * @class\r\n * @hideconstructor\r\n */\n\n\nfunction Subscription(options) {\n  EventEmitter.call(this);\n  this.id = null;\n  this.callback = null;\n  this.arguments = null;\n  this._reconnectIntervalId = null;\n  this.options = {\n    subscription: options.subscription,\n    type: options.type,\n    requestManager: options.requestManager\n  };\n}\n\nSubscription.prototype = Object.create(EventEmitter.prototype, {\n  constructor: {\n    value: Subscription\n  }\n});\n/**\r\n * Should be used to extract callback from array of arguments. Modifies input param\r\n *\r\n * @ignore\r\n * @method _extractCallback\r\n * @param {Array} arguments\r\n * @return {Function|Null} callback, if exists\r\n */\n\nSubscription.prototype._extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\r\n * Should be called to check if the number of arguments is correct\r\n *\r\n * @ignore\r\n * @method _validateArgs\r\n * @param {Array} arguments\r\n * @throws {Error} if it is not\r\n */\n\n\nSubscription.prototype._validateArgs = function (args) {\n  let subscription = this.options.subscription;\n\n  if (!subscription) {\n    subscription = {};\n  }\n\n  if (!subscription.params) {\n    subscription.params = 0;\n  }\n\n  if (args.length !== subscription.params) {\n    throw errors.InvalidNumberOfParams(args.length, subscription.params + 1, args[0]);\n  }\n};\n/**\r\n * Should be called to format input args of method\r\n *\r\n * @ignore\r\n * @method _formatInput\r\n * @param {Array}\r\n * @return {Array}\r\n */\n\n\nSubscription.prototype._formatInput = function (args) {\n  const subscription = this.options.subscription;\n\n  if (!subscription) {\n    return args;\n  }\n\n  if (!subscription.inputFormatter) {\n    return args;\n  }\n\n  const formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n    return formatter ? formatter(args[index]) : args[index];\n  });\n  return formattedArgs;\n};\n/**\r\n * Should be called to format output(result) of method\r\n *\r\n * @ignore\r\n * @method _formatOutput\r\n * @param {Object}\r\n * @return {Object}\r\n */\n\n\nSubscription.prototype._formatOutput = function (result) {\n  const subscription = this.options.subscription;\n  return subscription && subscription.outputFormatter && result ? subscription.outputFormatter(result) : result;\n};\n/**\r\n * Should create payload from given input args\r\n *\r\n * @ignore\r\n * @method _toPayload\r\n * @param {Array} args\r\n * @return {Object}\r\n */\n\n\nSubscription.prototype._toPayload = function (args) {\n  let params = [];\n  this.callback = this._extractCallback(args);\n\n  if (!this.subscriptionMethod) {\n    this.subscriptionMethod = args.shift();\n\n    if (this.options.subscription.subscriptionName) {\n      this.subscriptionMethod = this.options.subscription.subscriptionName;\n    }\n  }\n\n  if (!this.arguments) {\n    this.arguments = this._formatInput(args);\n\n    this._validateArgs(this.arguments);\n\n    args = []; // make empty after validation\n  } // re-add subscriptionName\n\n\n  params.push(this.subscriptionMethod);\n  params = params.concat(this.arguments);\n\n  if (args.length) {\n    throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n  }\n\n  return {\n    method: `${this.options.type}_subscribe`,\n    params: params\n  };\n};\n/**\r\n * Unsubscribes and clears callbacks.\r\n *\r\n * @return {Object}\r\n */\n\n\nSubscription.prototype.unsubscribe = function (callback) {\n  this.options.requestManager.removeSubscription(this.id, callback);\n  this.id = null;\n  this.removeAllListeners();\n  clearInterval(this._reconnectIntervalId);\n};\n/**\r\n * Subscribes and watches for changes\r\n *\r\n * @param {String} subscription the subscription\r\n * @param {Object} options the options object with address topics and fromBlock\r\n * @return {Object}\r\n */\n\n\nSubscription.prototype.subscribe = function () {\n  const _this = this;\n\n  const args = Array.prototype.slice.call(arguments);\n\n  const payload = this._toPayload(args);\n\n  if (!payload) {\n    return this;\n  }\n\n  if (!this.options.requestManager.provider) {\n    const err1 = new Error('No provider set.');\n    this.callback(err1, null, this);\n    /**\r\n     * Subscription 'error' event.\r\n     *\r\n     * @event Subscription#error\r\n     * @type {Error}\r\n     */\n\n    this.emit('error', err1);\n    return this;\n  }\n\n  if (!this.options.requestManager.provider.on) {\n    const err2 = new Error(`The current provider doesn't support subscriptions: ${this.options.requestManager.provider.constructor.name}`);\n    this.callback(err2, null, this);\n    this.emit('error', err2);\n    return this;\n  }\n\n  if (this.id) {\n    this.unsubscribe();\n  }\n\n  this.options.params = payload.params[1]; // get past logs, if fromBlock is available\n\n  if (payload.params[0] === 'logs' && _.isObject(payload.params[1]) && Object.prototype.hasOwnProperty.call(payload.params[1], 'fromBlock') && isFinite(payload.params[1].fromBlock)) {\n    // send the subscription request\n    // copy the params to avoid race-condition with deletion below this block\n    const blockParams = { ...payload.params[1]\n    };\n    this.options.requestManager.send({\n      method: 'klay_getLogs',\n      params: [blockParams]\n    }, function (err, logs) {\n      if (!err) {\n        logs.forEach(function (log) {\n          const output = _this._formatOutput(log);\n\n          _this.callback(null, output, _this);\n          /**\r\n           * Subscription 'data' event.\r\n           *\r\n           * @event Subscription#data\r\n           * @type {object}\r\n           */\n\n\n          _this.emit('data', output);\n        }); // TODO subscribe here? after the past logs?\n      } else {\n        _this.callback(err, null, _this);\n\n        _this.emit('error', err);\n      }\n    });\n  } // create subscription\n  // TODO move to separate function? so that past logs can go first?\n\n\n  if (typeof payload.params[1] === 'object') {\n    delete payload.params[1].fromBlock;\n  }\n\n  this.options.requestManager.send(payload, function (err, result) {\n    if (!err && result) {\n      _this.id = result;\n      /**\r\n       * Subscription 'connected' event.\r\n       *\r\n       * @event Subscription#connected\r\n       * @type {string}\r\n       */\n\n      _this.emit('connected', result); // call callback on notifications\n\n\n      _this.options.requestManager.addSubscription(_this.id, payload.params[0], _this.options.type, function (error, ret) {\n        if (!error) {\n          if (!_.isArray(ret)) {\n            ret = [ret];\n          }\n\n          ret.forEach(function (resultItem) {\n            const output = _this._formatOutput(resultItem);\n\n            if (_.isFunction(_this.options.subscription.subscriptionHandler)) {\n              return _this.options.subscription.subscriptionHandler.call(_this, output);\n            }\n\n            _this.emit('data', output); // call the callback, last so that unsubscribe there won't affect the emit above\n\n\n            if (_.isFunction(_this.callback)) {\n              _this.callback(null, output, _this);\n            }\n          });\n        } else {\n          // unsubscribe, but keep listeners\n          _this.options.requestManager.removeSubscription(_this.id); // re-subscribe, if connection fails\n\n\n          if (_this.options.requestManager.provider.once) {\n            _this._reconnectIntervalId = setInterval(function () {\n              // TODO check if that makes sense!\n              if (_this.options.requestManager.provider.reconnect) {\n                _this.options.requestManager.provider.reconnect();\n              }\n            }, 500);\n\n            _this.options.requestManager.provider.once('connect', function () {\n              clearInterval(_this._reconnectIntervalId);\n\n              _this.subscribe(_this.callback);\n            });\n          }\n\n          _this.emit('error', error); // call the callback, last so that unsubscribe there won't affect the emit above\n\n\n          if (_.isFunction(_this.callback)) {\n            _this.callback(error, null, _this);\n          }\n        }\n      });\n    } else if (_.isFunction(_this.callback)) {\n      _this.callback(err, null, _this);\n\n      _this.emit('error', err);\n    } else {\n      // emit the event even if no callback was provided\n      _this.emit('error', err);\n    }\n  }); // return an object to cancel the subscription\n\n  return this;\n};\n\nmodule.exports = Subscription;","map":{"version":3,"sources":["C:/Users/kimyo/skkrypto project/skkrypto-front-solidity/node_modules/caver-js/packages/caver-core-subscriptions/src/subscription.js"],"names":["_","require","EventEmitter","errors","Subscription","options","call","id","callback","arguments","_reconnectIntervalId","subscription","type","requestManager","prototype","Object","create","constructor","value","_extractCallback","args","isFunction","length","pop","_validateArgs","params","InvalidNumberOfParams","_formatInput","inputFormatter","formattedArgs","map","formatter","index","_formatOutput","result","outputFormatter","_toPayload","subscriptionMethod","shift","subscriptionName","push","concat","Error","method","unsubscribe","removeSubscription","removeAllListeners","clearInterval","subscribe","_this","Array","slice","payload","provider","err1","emit","on","err2","name","isObject","hasOwnProperty","isFinite","fromBlock","blockParams","send","err","logs","forEach","log","output","addSubscription","error","ret","isArray","resultItem","subscriptionHandler","once","setInterval","reconnect","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,MAAMC,YAAY,GAAGD,OAAO,CAAC,eAAD,CAA5B;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,0BAAD,CAAP,CAAoCE,MAAnD;AAEA;AACA;AACA;AACA;AACA;;;AACA,SAASC,YAAT,CAAsBC,OAAtB,EAA+B;AAC3BH,EAAAA,YAAY,CAACI,IAAb,CAAkB,IAAlB;AAEA,OAAKC,EAAL,GAAU,IAAV;AACA,OAAKC,QAAL,GAAgB,IAAhB;AACA,OAAKC,SAAL,GAAiB,IAAjB;AACA,OAAKC,oBAAL,GAA4B,IAA5B;AAEA,OAAKL,OAAL,GAAe;AACXM,IAAAA,YAAY,EAAEN,OAAO,CAACM,YADX;AAEXC,IAAAA,IAAI,EAAEP,OAAO,CAACO,IAFH;AAGXC,IAAAA,cAAc,EAAER,OAAO,CAACQ;AAHb,GAAf;AAKH;;AAEDT,YAAY,CAACU,SAAb,GAAyBC,MAAM,CAACC,MAAP,CAAcd,YAAY,CAACY,SAA3B,EAAsC;AAC3DG,EAAAA,WAAW,EAAE;AAAEC,IAAAA,KAAK,EAAEd;AAAT;AAD8C,CAAtC,CAAzB;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,YAAY,CAACU,SAAb,CAAuBK,gBAAvB,GAA0C,UAASC,IAAT,EAAe;AACrD,MAAIpB,CAAC,CAACqB,UAAF,CAAaD,IAAI,CAACA,IAAI,CAACE,MAAL,GAAc,CAAf,CAAjB,CAAJ,EAAyC;AACrC,WAAOF,IAAI,CAACG,GAAL,EAAP,CADqC,CACnB;AACrB;AACJ,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAnB,YAAY,CAACU,SAAb,CAAuBU,aAAvB,GAAuC,UAASJ,IAAT,EAAe;AAClD,MAAIT,YAAY,GAAG,KAAKN,OAAL,CAAaM,YAAhC;;AAEA,MAAI,CAACA,YAAL,EAAmB;AACfA,IAAAA,YAAY,GAAG,EAAf;AACH;;AAED,MAAI,CAACA,YAAY,CAACc,MAAlB,EAA0B;AACtBd,IAAAA,YAAY,CAACc,MAAb,GAAsB,CAAtB;AACH;;AAED,MAAIL,IAAI,CAACE,MAAL,KAAgBX,YAAY,CAACc,MAAjC,EAAyC;AACrC,UAAMtB,MAAM,CAACuB,qBAAP,CAA6BN,IAAI,CAACE,MAAlC,EAA0CX,YAAY,CAACc,MAAb,GAAsB,CAAhE,EAAmEL,IAAI,CAAC,CAAD,CAAvE,CAAN;AACH;AACJ,CAdD;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAhB,YAAY,CAACU,SAAb,CAAuBa,YAAvB,GAAsC,UAASP,IAAT,EAAe;AACjD,QAAMT,YAAY,GAAG,KAAKN,OAAL,CAAaM,YAAlC;;AAEA,MAAI,CAACA,YAAL,EAAmB;AACf,WAAOS,IAAP;AACH;;AAED,MAAI,CAACT,YAAY,CAACiB,cAAlB,EAAkC;AAC9B,WAAOR,IAAP;AACH;;AAED,QAAMS,aAAa,GAAGlB,YAAY,CAACiB,cAAb,CAA4BE,GAA5B,CAAgC,UAASC,SAAT,EAAoBC,KAApB,EAA2B;AAC7E,WAAOD,SAAS,GAAGA,SAAS,CAACX,IAAI,CAACY,KAAD,CAAL,CAAZ,GAA4BZ,IAAI,CAACY,KAAD,CAAhD;AACH,GAFqB,CAAtB;AAIA,SAAOH,aAAP;AACH,CAhBD;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAzB,YAAY,CAACU,SAAb,CAAuBmB,aAAvB,GAAuC,UAASC,MAAT,EAAiB;AACpD,QAAMvB,YAAY,GAAG,KAAKN,OAAL,CAAaM,YAAlC;AAEA,SAAOA,YAAY,IAAIA,YAAY,CAACwB,eAA7B,IAAgDD,MAAhD,GAAyDvB,YAAY,CAACwB,eAAb,CAA6BD,MAA7B,CAAzD,GAAgGA,MAAvG;AACH,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA9B,YAAY,CAACU,SAAb,CAAuBsB,UAAvB,GAAoC,UAAShB,IAAT,EAAe;AAC/C,MAAIK,MAAM,GAAG,EAAb;AACA,OAAKjB,QAAL,GAAgB,KAAKW,gBAAL,CAAsBC,IAAtB,CAAhB;;AAEA,MAAI,CAAC,KAAKiB,kBAAV,EAA8B;AAC1B,SAAKA,kBAAL,GAA0BjB,IAAI,CAACkB,KAAL,EAA1B;;AAEA,QAAI,KAAKjC,OAAL,CAAaM,YAAb,CAA0B4B,gBAA9B,EAAgD;AAC5C,WAAKF,kBAAL,GAA0B,KAAKhC,OAAL,CAAaM,YAAb,CAA0B4B,gBAApD;AACH;AACJ;;AAED,MAAI,CAAC,KAAK9B,SAAV,EAAqB;AACjB,SAAKA,SAAL,GAAiB,KAAKkB,YAAL,CAAkBP,IAAlB,CAAjB;;AACA,SAAKI,aAAL,CAAmB,KAAKf,SAAxB;;AACAW,IAAAA,IAAI,GAAG,EAAP,CAHiB,CAGP;AACb,GAhB8C,CAkB/C;;;AACAK,EAAAA,MAAM,CAACe,IAAP,CAAY,KAAKH,kBAAjB;AACAZ,EAAAA,MAAM,GAAGA,MAAM,CAACgB,MAAP,CAAc,KAAKhC,SAAnB,CAAT;;AAEA,MAAIW,IAAI,CAACE,MAAT,EAAiB;AACb,UAAM,IAAIoB,KAAJ,CAAU,kFAAV,CAAN;AACH;;AAED,SAAO;AACHC,IAAAA,MAAM,EAAG,GAAE,KAAKtC,OAAL,CAAaO,IAAK,YAD1B;AAEHa,IAAAA,MAAM,EAAEA;AAFL,GAAP;AAIH,CA9BD;AAgCA;AACA;AACA;AACA;AACA;;;AACArB,YAAY,CAACU,SAAb,CAAuB8B,WAAvB,GAAqC,UAASpC,QAAT,EAAmB;AACpD,OAAKH,OAAL,CAAaQ,cAAb,CAA4BgC,kBAA5B,CAA+C,KAAKtC,EAApD,EAAwDC,QAAxD;AACA,OAAKD,EAAL,GAAU,IAAV;AACA,OAAKuC,kBAAL;AACAC,EAAAA,aAAa,CAAC,KAAKrC,oBAAN,CAAb;AACH,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAN,YAAY,CAACU,SAAb,CAAuBkC,SAAvB,GAAmC,YAAW;AAC1C,QAAMC,KAAK,GAAG,IAAd;;AACA,QAAM7B,IAAI,GAAG8B,KAAK,CAACpC,SAAN,CAAgBqC,KAAhB,CAAsB7C,IAAtB,CAA2BG,SAA3B,CAAb;;AACA,QAAM2C,OAAO,GAAG,KAAKhB,UAAL,CAAgBhB,IAAhB,CAAhB;;AAEA,MAAI,CAACgC,OAAL,EAAc;AACV,WAAO,IAAP;AACH;;AAED,MAAI,CAAC,KAAK/C,OAAL,CAAaQ,cAAb,CAA4BwC,QAAjC,EAA2C;AACvC,UAAMC,IAAI,GAAG,IAAIZ,KAAJ,CAAU,kBAAV,CAAb;AACA,SAAKlC,QAAL,CAAc8C,IAAd,EAAoB,IAApB,EAA0B,IAA1B;AAEA;AACR;AACA;AACA;AACA;AACA;;AACQ,SAAKC,IAAL,CAAU,OAAV,EAAmBD,IAAnB;AACA,WAAO,IAAP;AACH;;AAED,MAAI,CAAC,KAAKjD,OAAL,CAAaQ,cAAb,CAA4BwC,QAA5B,CAAqCG,EAA1C,EAA8C;AAC1C,UAAMC,IAAI,GAAG,IAAIf,KAAJ,CACR,uDAAsD,KAAKrC,OAAL,CAAaQ,cAAb,CAA4BwC,QAA5B,CAAqCpC,WAArC,CAAiDyC,IAAK,EADpG,CAAb;AAGA,SAAKlD,QAAL,CAAciD,IAAd,EAAoB,IAApB,EAA0B,IAA1B;AACA,SAAKF,IAAL,CAAU,OAAV,EAAmBE,IAAnB;AACA,WAAO,IAAP;AACH;;AAED,MAAI,KAAKlD,EAAT,EAAa;AACT,SAAKqC,WAAL;AACH;;AAED,OAAKvC,OAAL,CAAaoB,MAAb,GAAsB2B,OAAO,CAAC3B,MAAR,CAAe,CAAf,CAAtB,CApC0C,CAsC1C;;AACA,MACI2B,OAAO,CAAC3B,MAAR,CAAe,CAAf,MAAsB,MAAtB,IACAzB,CAAC,CAAC2D,QAAF,CAAWP,OAAO,CAAC3B,MAAR,CAAe,CAAf,CAAX,CADA,IAEAV,MAAM,CAACD,SAAP,CAAiB8C,cAAjB,CAAgCtD,IAAhC,CAAqC8C,OAAO,CAAC3B,MAAR,CAAe,CAAf,CAArC,EAAwD,WAAxD,CAFA,IAGAoC,QAAQ,CAACT,OAAO,CAAC3B,MAAR,CAAe,CAAf,EAAkBqC,SAAnB,CAJZ,EAKE;AACE;AAEA;AACA,UAAMC,WAAW,GAAG,EAAE,GAAGX,OAAO,CAAC3B,MAAR,CAAe,CAAf;AAAL,KAApB;AAEA,SAAKpB,OAAL,CAAaQ,cAAb,CAA4BmD,IAA5B,CACI;AACIrB,MAAAA,MAAM,EAAE,cADZ;AAEIlB,MAAAA,MAAM,EAAE,CAACsC,WAAD;AAFZ,KADJ,EAKI,UAASE,GAAT,EAAcC,IAAd,EAAoB;AAChB,UAAI,CAACD,GAAL,EAAU;AACNC,QAAAA,IAAI,CAACC,OAAL,CAAa,UAASC,GAAT,EAAc;AACvB,gBAAMC,MAAM,GAAGpB,KAAK,CAAChB,aAAN,CAAoBmC,GAApB,CAAf;;AACAnB,UAAAA,KAAK,CAACzC,QAAN,CAAe,IAAf,EAAqB6D,MAArB,EAA6BpB,KAA7B;AACA;AACxB;AACA;AACA;AACA;AACA;;;AACwBA,UAAAA,KAAK,CAACM,IAAN,CAAW,MAAX,EAAmBc,MAAnB;AACH,SAVD,EADM,CAaN;AACH,OAdD,MAcO;AACHpB,QAAAA,KAAK,CAACzC,QAAN,CAAeyD,GAAf,EAAoB,IAApB,EAA0BhB,KAA1B;;AACAA,QAAAA,KAAK,CAACM,IAAN,CAAW,OAAX,EAAoBU,GAApB;AACH;AACJ,KAxBL;AA0BH,GA5EyC,CA8E1C;AACA;;;AAEA,MAAI,OAAOb,OAAO,CAAC3B,MAAR,CAAe,CAAf,CAAP,KAA6B,QAAjC,EAA2C;AACvC,WAAO2B,OAAO,CAAC3B,MAAR,CAAe,CAAf,EAAkBqC,SAAzB;AACH;;AAED,OAAKzD,OAAL,CAAaQ,cAAb,CAA4BmD,IAA5B,CAAiCZ,OAAjC,EAA0C,UAASa,GAAT,EAAc/B,MAAd,EAAsB;AAC5D,QAAI,CAAC+B,GAAD,IAAQ/B,MAAZ,EAAoB;AAChBe,MAAAA,KAAK,CAAC1C,EAAN,GAAW2B,MAAX;AACA;AACZ;AACA;AACA;AACA;AACA;;AACYe,MAAAA,KAAK,CAACM,IAAN,CAAW,WAAX,EAAwBrB,MAAxB,EARgB,CAUhB;;;AACAe,MAAAA,KAAK,CAAC5C,OAAN,CAAcQ,cAAd,CAA6ByD,eAA7B,CAA6CrB,KAAK,CAAC1C,EAAnD,EAAuD6C,OAAO,CAAC3B,MAAR,CAAe,CAAf,CAAvD,EAA0EwB,KAAK,CAAC5C,OAAN,CAAcO,IAAxF,EAA8F,UAAS2D,KAAT,EAAgBC,GAAhB,EAAqB;AAC/G,YAAI,CAACD,KAAL,EAAY;AACR,cAAI,CAACvE,CAAC,CAACyE,OAAF,CAAUD,GAAV,CAAL,EAAqB;AACjBA,YAAAA,GAAG,GAAG,CAACA,GAAD,CAAN;AACH;;AAEDA,UAAAA,GAAG,CAACL,OAAJ,CAAY,UAASO,UAAT,EAAqB;AAC7B,kBAAML,MAAM,GAAGpB,KAAK,CAAChB,aAAN,CAAoByC,UAApB,CAAf;;AAEA,gBAAI1E,CAAC,CAACqB,UAAF,CAAa4B,KAAK,CAAC5C,OAAN,CAAcM,YAAd,CAA2BgE,mBAAxC,CAAJ,EAAkE;AAC9D,qBAAO1B,KAAK,CAAC5C,OAAN,CAAcM,YAAd,CAA2BgE,mBAA3B,CAA+CrE,IAA/C,CAAoD2C,KAApD,EAA2DoB,MAA3D,CAAP;AACH;;AACDpB,YAAAA,KAAK,CAACM,IAAN,CAAW,MAAX,EAAmBc,MAAnB,EAN6B,CAQ7B;;;AACA,gBAAIrE,CAAC,CAACqB,UAAF,CAAa4B,KAAK,CAACzC,QAAnB,CAAJ,EAAkC;AAC9ByC,cAAAA,KAAK,CAACzC,QAAN,CAAe,IAAf,EAAqB6D,MAArB,EAA6BpB,KAA7B;AACH;AACJ,WAZD;AAaH,SAlBD,MAkBO;AACH;AACAA,UAAAA,KAAK,CAAC5C,OAAN,CAAcQ,cAAd,CAA6BgC,kBAA7B,CAAgDI,KAAK,CAAC1C,EAAtD,EAFG,CAIH;;;AACA,cAAI0C,KAAK,CAAC5C,OAAN,CAAcQ,cAAd,CAA6BwC,QAA7B,CAAsCuB,IAA1C,EAAgD;AAC5C3B,YAAAA,KAAK,CAACvC,oBAAN,GAA6BmE,WAAW,CAAC,YAAW;AAChD;AACA,kBAAI5B,KAAK,CAAC5C,OAAN,CAAcQ,cAAd,CAA6BwC,QAA7B,CAAsCyB,SAA1C,EAAqD;AACjD7B,gBAAAA,KAAK,CAAC5C,OAAN,CAAcQ,cAAd,CAA6BwC,QAA7B,CAAsCyB,SAAtC;AACH;AACJ,aALuC,EAKrC,GALqC,CAAxC;;AAOA7B,YAAAA,KAAK,CAAC5C,OAAN,CAAcQ,cAAd,CAA6BwC,QAA7B,CAAsCuB,IAAtC,CAA2C,SAA3C,EAAsD,YAAW;AAC7D7B,cAAAA,aAAa,CAACE,KAAK,CAACvC,oBAAP,CAAb;;AACAuC,cAAAA,KAAK,CAACD,SAAN,CAAgBC,KAAK,CAACzC,QAAtB;AACH,aAHD;AAIH;;AACDyC,UAAAA,KAAK,CAACM,IAAN,CAAW,OAAX,EAAoBgB,KAApB,EAlBG,CAoBH;;;AACA,cAAIvE,CAAC,CAACqB,UAAF,CAAa4B,KAAK,CAACzC,QAAnB,CAAJ,EAAkC;AAC9ByC,YAAAA,KAAK,CAACzC,QAAN,CAAe+D,KAAf,EAAsB,IAAtB,EAA4BtB,KAA5B;AACH;AACJ;AACJ,OA5CD;AA6CH,KAxDD,MAwDO,IAAIjD,CAAC,CAACqB,UAAF,CAAa4B,KAAK,CAACzC,QAAnB,CAAJ,EAAkC;AACrCyC,MAAAA,KAAK,CAACzC,QAAN,CAAeyD,GAAf,EAAoB,IAApB,EAA0BhB,KAA1B;;AACAA,MAAAA,KAAK,CAACM,IAAN,CAAW,OAAX,EAAoBU,GAApB;AACH,KAHM,MAGA;AACH;AACAhB,MAAAA,KAAK,CAACM,IAAN,CAAW,OAAX,EAAoBU,GAApB;AACH;AACJ,GAhED,EArF0C,CAsJ1C;;AACA,SAAO,IAAP;AACH,CAxJD;;AA0JAc,MAAM,CAACC,OAAP,GAAiB5E,YAAjB","sourcesContent":["/*\r\n    Modifications copyright 2018 The caver-js Authors\r\n    This file is part of web3.js.\r\n\r\n    web3.js is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    web3.js is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n    You should have received a copy of the GNU Lesser General Public License\r\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n    This file is derived from web3.js/packages/web3-core-subscriptions/src/subscription.js (2019/06/12).\r\n    Modified and improved for the caver-js development.\r\n*/\r\n/**\r\n * @file subscription.js\r\n * @author Fabian Vogelsteller <fabian@ethereum.org>\r\n * @date 2017\r\n */\r\n\r\nconst _ = require('lodash')\r\nconst EventEmitter = require('eventemitter3')\r\nconst errors = require('../../caver-core-helpers').errors\r\n\r\n/**\r\n * @classdesc A subscription class implemented to subscribe the specific events in the blockchain.\r\n * @class\r\n * @hideconstructor\r\n */\r\nfunction Subscription(options) {\r\n    EventEmitter.call(this)\r\n\r\n    this.id = null\r\n    this.callback = null\r\n    this.arguments = null\r\n    this._reconnectIntervalId = null\r\n\r\n    this.options = {\r\n        subscription: options.subscription,\r\n        type: options.type,\r\n        requestManager: options.requestManager,\r\n    }\r\n}\r\n\r\nSubscription.prototype = Object.create(EventEmitter.prototype, {\r\n    constructor: { value: Subscription },\r\n})\r\n\r\n/**\r\n * Should be used to extract callback from array of arguments. Modifies input param\r\n *\r\n * @ignore\r\n * @method _extractCallback\r\n * @param {Array} arguments\r\n * @return {Function|Null} callback, if exists\r\n */\r\nSubscription.prototype._extractCallback = function(args) {\r\n    if (_.isFunction(args[args.length - 1])) {\r\n        return args.pop() // modify the args array!\r\n    }\r\n}\r\n\r\n/**\r\n * Should be called to check if the number of arguments is correct\r\n *\r\n * @ignore\r\n * @method _validateArgs\r\n * @param {Array} arguments\r\n * @throws {Error} if it is not\r\n */\r\nSubscription.prototype._validateArgs = function(args) {\r\n    let subscription = this.options.subscription\r\n\r\n    if (!subscription) {\r\n        subscription = {}\r\n    }\r\n\r\n    if (!subscription.params) {\r\n        subscription.params = 0\r\n    }\r\n\r\n    if (args.length !== subscription.params) {\r\n        throw errors.InvalidNumberOfParams(args.length, subscription.params + 1, args[0])\r\n    }\r\n}\r\n\r\n/**\r\n * Should be called to format input args of method\r\n *\r\n * @ignore\r\n * @method _formatInput\r\n * @param {Array}\r\n * @return {Array}\r\n */\r\nSubscription.prototype._formatInput = function(args) {\r\n    const subscription = this.options.subscription\r\n\r\n    if (!subscription) {\r\n        return args\r\n    }\r\n\r\n    if (!subscription.inputFormatter) {\r\n        return args\r\n    }\r\n\r\n    const formattedArgs = subscription.inputFormatter.map(function(formatter, index) {\r\n        return formatter ? formatter(args[index]) : args[index]\r\n    })\r\n\r\n    return formattedArgs\r\n}\r\n\r\n/**\r\n * Should be called to format output(result) of method\r\n *\r\n * @ignore\r\n * @method _formatOutput\r\n * @param {Object}\r\n * @return {Object}\r\n */\r\nSubscription.prototype._formatOutput = function(result) {\r\n    const subscription = this.options.subscription\r\n\r\n    return subscription && subscription.outputFormatter && result ? subscription.outputFormatter(result) : result\r\n}\r\n\r\n/**\r\n * Should create payload from given input args\r\n *\r\n * @ignore\r\n * @method _toPayload\r\n * @param {Array} args\r\n * @return {Object}\r\n */\r\nSubscription.prototype._toPayload = function(args) {\r\n    let params = []\r\n    this.callback = this._extractCallback(args)\r\n\r\n    if (!this.subscriptionMethod) {\r\n        this.subscriptionMethod = args.shift()\r\n\r\n        if (this.options.subscription.subscriptionName) {\r\n            this.subscriptionMethod = this.options.subscription.subscriptionName\r\n        }\r\n    }\r\n\r\n    if (!this.arguments) {\r\n        this.arguments = this._formatInput(args)\r\n        this._validateArgs(this.arguments)\r\n        args = [] // make empty after validation\r\n    }\r\n\r\n    // re-add subscriptionName\r\n    params.push(this.subscriptionMethod)\r\n    params = params.concat(this.arguments)\r\n\r\n    if (args.length) {\r\n        throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.')\r\n    }\r\n\r\n    return {\r\n        method: `${this.options.type}_subscribe`,\r\n        params: params,\r\n    }\r\n}\r\n\r\n/**\r\n * Unsubscribes and clears callbacks.\r\n *\r\n * @return {Object}\r\n */\r\nSubscription.prototype.unsubscribe = function(callback) {\r\n    this.options.requestManager.removeSubscription(this.id, callback)\r\n    this.id = null\r\n    this.removeAllListeners()\r\n    clearInterval(this._reconnectIntervalId)\r\n}\r\n\r\n/**\r\n * Subscribes and watches for changes\r\n *\r\n * @param {String} subscription the subscription\r\n * @param {Object} options the options object with address topics and fromBlock\r\n * @return {Object}\r\n */\r\nSubscription.prototype.subscribe = function() {\r\n    const _this = this\r\n    const args = Array.prototype.slice.call(arguments)\r\n    const payload = this._toPayload(args)\r\n\r\n    if (!payload) {\r\n        return this\r\n    }\r\n\r\n    if (!this.options.requestManager.provider) {\r\n        const err1 = new Error('No provider set.')\r\n        this.callback(err1, null, this)\r\n\r\n        /**\r\n         * Subscription 'error' event.\r\n         *\r\n         * @event Subscription#error\r\n         * @type {Error}\r\n         */\r\n        this.emit('error', err1)\r\n        return this\r\n    }\r\n\r\n    if (!this.options.requestManager.provider.on) {\r\n        const err2 = new Error(\r\n            `The current provider doesn't support subscriptions: ${this.options.requestManager.provider.constructor.name}`\r\n        )\r\n        this.callback(err2, null, this)\r\n        this.emit('error', err2)\r\n        return this\r\n    }\r\n\r\n    if (this.id) {\r\n        this.unsubscribe()\r\n    }\r\n\r\n    this.options.params = payload.params[1]\r\n\r\n    // get past logs, if fromBlock is available\r\n    if (\r\n        payload.params[0] === 'logs' &&\r\n        _.isObject(payload.params[1]) &&\r\n        Object.prototype.hasOwnProperty.call(payload.params[1], 'fromBlock') &&\r\n        isFinite(payload.params[1].fromBlock)\r\n    ) {\r\n        // send the subscription request\r\n\r\n        // copy the params to avoid race-condition with deletion below this block\r\n        const blockParams = { ...payload.params[1] }\r\n\r\n        this.options.requestManager.send(\r\n            {\r\n                method: 'klay_getLogs',\r\n                params: [blockParams],\r\n            },\r\n            function(err, logs) {\r\n                if (!err) {\r\n                    logs.forEach(function(log) {\r\n                        const output = _this._formatOutput(log)\r\n                        _this.callback(null, output, _this)\r\n                        /**\r\n                         * Subscription 'data' event.\r\n                         *\r\n                         * @event Subscription#data\r\n                         * @type {object}\r\n                         */\r\n                        _this.emit('data', output)\r\n                    })\r\n\r\n                    // TODO subscribe here? after the past logs?\r\n                } else {\r\n                    _this.callback(err, null, _this)\r\n                    _this.emit('error', err)\r\n                }\r\n            }\r\n        )\r\n    }\r\n\r\n    // create subscription\r\n    // TODO move to separate function? so that past logs can go first?\r\n\r\n    if (typeof payload.params[1] === 'object') {\r\n        delete payload.params[1].fromBlock\r\n    }\r\n\r\n    this.options.requestManager.send(payload, function(err, result) {\r\n        if (!err && result) {\r\n            _this.id = result\r\n            /**\r\n             * Subscription 'connected' event.\r\n             *\r\n             * @event Subscription#connected\r\n             * @type {string}\r\n             */\r\n            _this.emit('connected', result)\r\n\r\n            // call callback on notifications\r\n            _this.options.requestManager.addSubscription(_this.id, payload.params[0], _this.options.type, function(error, ret) {\r\n                if (!error) {\r\n                    if (!_.isArray(ret)) {\r\n                        ret = [ret]\r\n                    }\r\n\r\n                    ret.forEach(function(resultItem) {\r\n                        const output = _this._formatOutput(resultItem)\r\n\r\n                        if (_.isFunction(_this.options.subscription.subscriptionHandler)) {\r\n                            return _this.options.subscription.subscriptionHandler.call(_this, output)\r\n                        }\r\n                        _this.emit('data', output)\r\n\r\n                        // call the callback, last so that unsubscribe there won't affect the emit above\r\n                        if (_.isFunction(_this.callback)) {\r\n                            _this.callback(null, output, _this)\r\n                        }\r\n                    })\r\n                } else {\r\n                    // unsubscribe, but keep listeners\r\n                    _this.options.requestManager.removeSubscription(_this.id)\r\n\r\n                    // re-subscribe, if connection fails\r\n                    if (_this.options.requestManager.provider.once) {\r\n                        _this._reconnectIntervalId = setInterval(function() {\r\n                            // TODO check if that makes sense!\r\n                            if (_this.options.requestManager.provider.reconnect) {\r\n                                _this.options.requestManager.provider.reconnect()\r\n                            }\r\n                        }, 500)\r\n\r\n                        _this.options.requestManager.provider.once('connect', function() {\r\n                            clearInterval(_this._reconnectIntervalId)\r\n                            _this.subscribe(_this.callback)\r\n                        })\r\n                    }\r\n                    _this.emit('error', error)\r\n\r\n                    // call the callback, last so that unsubscribe there won't affect the emit above\r\n                    if (_.isFunction(_this.callback)) {\r\n                        _this.callback(error, null, _this)\r\n                    }\r\n                }\r\n            })\r\n        } else if (_.isFunction(_this.callback)) {\r\n            _this.callback(err, null, _this)\r\n            _this.emit('error', err)\r\n        } else {\r\n            // emit the event even if no callback was provided\r\n            _this.emit('error', err)\r\n        }\r\n    })\r\n    // return an object to cancel the subscription\r\n    return this\r\n}\r\n\r\nmodule.exports = Subscription\r\n"]},"metadata":{},"sourceType":"script"}